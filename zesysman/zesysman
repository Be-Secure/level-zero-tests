#!/usr/bin/env python3
# Copyright (C) 2020 Intel Corporation
# SPDX-License-Identifier: MIT

import argparse
import os
import os.path
import re
import signal
import sys
import time
import traceback
import xml.etree.ElementTree as ElementTree
import xml.dom.minidom as minidom

from zesysman import *

ZESYSMAN_PROG_VERSION = "version 0.2"

#
# Output support
#

class Logger:
    def __init__(self):
        self.outputFile = sys.stdout
        self.debugFile = None
        self.teeOutput = False

    # Print to standard error
    def err(self, *args, **kwargs):
        kwargs["file"] = sys.stderr
        print(*args, **kwargs)

    # Print to selected debug stream (suppressed when self.debugFile=None)
    def dbg(self, *args, **kwargs):
        if self.debugFile:
            kwargs["file"] = self.debugFile
            print(*args, **kwargs)

    # Print to current output file, copy to stdout if tee requested:
    def __call__(self, *args, **kwargs):
        kwargs["file"] = self.outputFile
        print(*args, **kwargs)
        if self.teeOutput:
            kwargs["file"] = sys.stdout
            print(*args, **kwargs)

    def fail(self, *args, **kwargs):
        self.err(*args, **kwargs)
        sys.exit(1)

pr = Logger()

def reportZeException():
    eType, eValue, eTrace = sys.exc_info()
    tb = traceback.format_tb(eTrace, limit=1)[0]
    match = re.search(r".*zeCall\((\w+)\s*,", tb)
    if match:
        pr.err("WARNING:", match.group(1), "returned", eValue)
    else:
        pr.err("WARNING:", eValue, "returned from\n", tb.rstrip())

#
# display formats
#

maxIterations = 1
indentStr = "    "
condensedList = False

IgnoreAttributes = [ "Number" ]
RenameAttributes = [ "Name", "Id" ]
IndexAttributes = [ "Index" ]
SecondaryIndexAttributes = [ "UUID" ]
DecorateAttributes = ["Units"]
TableRenameNodes = { "TemperatureSensor" : "Temp",
                     "PowerDomain" : "Power",
                     "FrequencyDomain" : "Freq",
                     "RequestedFrequency" : "Requested",
                     "ActualFrequency" : "Actual",
                     "MemoryModule" : "Mem",
                     "ErrorDomain" : "Err",
                     "FabricPort" : "Port",
                     "StandbyDomain" : "Standby",
                     "EngineGroup" : "",
                     "Activity" : "" }
TablePostRename = { "AllEngines" : "Util",
                    "AllComputeEngines" : "AllComputeUtil",
                    "AllMediaEngines" : "AllMediaUtil",
                    "AllCopyEngines" : "AllCopyUtil",
                    "ComputeEngine" : "ComputeUtil",
                    "RenderEngine" : "RenderUtil",
                    "MediaDecodeEngine" : "DecodeUtil",
                    "MediaEncodeEngine" : "EncodeUtil",
                    "CopyEngine" : "CopyUtil" }
TableKeepNodes = [ "PCI" ]

def tableNode(parent, node, text, *attrs):
    global maxIterations
    if parent is None:
        if maxIterations > 1:
            return (["Iteration"], [])
        else:
            return ([], [])
    elif len(parent) == 2:
        columns, rows = parent
        index = len(rows)
        rows.append({})

        for attr,val in attrs:
            if attr in IndexAttributes:
                if attr not in columns:
                    columns.append(attr)
                rows[index][attr] = str(val)
        return (columns, rows, index, "")
    else:
        node = TableRenameNodes.get(node, str(node))
        attrs = [ (a,v) for a,v in attrs if a not in IgnoreAttributes ]
        if text is None and node not in TableKeepNodes and not attrs:
            return parent
        if any(a in RenameAttributes for a,v in attrs):
            attrs = [ (a,v) for a,v in attrs if a not in IndexAttributes ]
        columns, rows, index, column = parent
        for attr,val in attrs:
            if node or column:
                node += "[" + str(val) + "]"
            else:
                node = str(val)
        node = TablePostRename.get(node, str(node))
        if column and node and node[0] != "[":
            column += "."
        column += node
        if text is not None:
            if column not in columns:
                columns.append(column)
            rows[index][column] = str(text)
        return (columns, rows, index, column)

def makeTableLine(chEnd, chLine, widths):
    return chEnd + chEnd.join([chLine * (w+2) for w in widths]) + chEnd

tableEndLine = ""

def tableOutputNode(node, currentIteration):
    global maxIterations, tableEndLine
    columns, rows = node
    widths = [ max([len(w)] + [len(r.get(w,"")) for r in rows]) for w in columns ]
    if currentIteration < 2:
        tableEndLine = makeTableLine("+", "-", widths)
        headings = [ " " + c + " " * (w - len(c)) + " " for c,w in zip(columns, widths) ]
        innerLine = makeTableLine("|", "=", widths)
        pr(tableEndLine)
        pr("|" + "|".join(headings) + "|")
        pr(innerLine)
    for row in rows:
        line = []
        if maxIterations > 1:
            row["Iteration"] = str(currentIteration)
        for column,width in zip(columns,widths):
            text = row.get(column, " " * (width // 2) + "-")
            line.append(" " + text + " " * (width - len(text)) + " ")
        pr("|" + "|".join(line) + "|")

def tableOutputComplete():
    global tableEndLine
    pr(tableEndLine)

def tableSetText(node, text, *attrs):
    if len(node) == 4:
        columns, rows, index, column = node
        rows[index][column] = str(text)

def csvQuote(s):
    s = s.replace('"','""')
    if '"' in s or "," in s or "\n" in s:
        return '"' + s + '"'
    else:
        return s

def csvOutputNode(node, currentIteration):
    global maxIterations
    columns, rows = node
    if currentIteration < 2:
        pr(",".join([ csvQuote(c) for c in columns ]))
    for row in rows:
        line = []
        if maxIterations > 1:
            row["Iteration"] = str(currentIteration)

        for column in columns:
            line.append(csvQuote(row.get(column,"")))
        pr(",".join(line))

def listNode(parent, node, text, *attrs):
    global maxIterations
    global indentStr
    if parent is None:
        if maxIterations > 1:
            children = [ indentStr ]
        else:
            children = [ "" ]
    else:
        indent = parent[0]
        n = indent + str(node)
        children = [ indent + indentStr ]
        attrs = [ (a,v) for a,v in attrs if a not in IgnoreAttributes ]
        for attr,val in attrs:
            if attr in RenameAttributes:
                n = indent + str(val)
            elif attr in IndexAttributes:
                n += " " + str(val)
            elif attr in SecondaryIndexAttributes:
                listNode(children, attr, val)
            elif attr in DecorateAttributes and text is not None:
                text = str(text) + " " + str(val)
            else:
                n += "." + attr + "_" + str(val)

        if text is None:
            parent.append(([n], children))
        else:
            leaf_node = [n, str(text)]
            parent.append((leaf_node, children))
            # this only works because all text nodes are leaf nodes:
            return leaf_node

    return children

def listDataIndent(i, node):
    for child, descendents in node[1:]:
        i = max(len(child[0]), i, listDataIndent(i, descendents))
    return i

def prListIndented(i, node):
    for child, descendents in node[1:]:
        if len(child) == 1:
            pr(child[0])
        else:
            pr(child[0] + " " * (i - len(child[0])), ":", " ".join(child[1:]))
        prListIndented(i, descendents)

def listOutputNode(node, currentIteration):
    global maxIterations
    global condensedList
    if maxIterations > 1:
        pr("\nIteration", currentIteration)
    if condensedList:
        prListIndented(0, node)
    else:
        prListIndented(listDataIndent(0, node), node)

def listSetText(node, text, *attrs):
    if len(node) == 2:
        text = str(text)
        for attr,val in attrs:
            if attr in DecorateAttributes:
                text += " " + str(val)
        node[1] = text

xmlIterationCount = None

def xmlNode(parent, node, text, *attrs):
    global maxIterations, xmlIterationCount
    if parent is None:
        if maxIterations > 1:
            if xmlIterationCount is None:
                xmlIterationCount = ElementTree.Element("Iteration")
                xmlIterationCount.set("Num", "?")
            e = ElementTree.SubElement(xmlIterationCount, node)
        else:
            new_elem = ElementTree.Element(node)
            e = new_elem
    else:
        new_elem = ElementTree.SubElement(parent, node)
        e = new_elem
    for attr, value in attrs:
        e.set(attr, str(value))
    if text is not None:
        e.text = str(text)
    return e

def xmlPrettyPrint(node):
    global indentStr
    xml = minidom.parseString(ElementTree.tostring(node))
    text = xml.toprettyxml(indent=indentStr).rstrip()
    return "\n".join(text.split("\n")[1:])

def xmlOutputNode(node, currentIteration):
    global maxIterations, xmlIterationCount
    if currentIteration == 1:
        pr('<?xml version="1.0" ?>')
    if maxIterations > 1 and xmlIterationCount is not None:
        xmlIterationCount.set("Num", str(currentIteration))
        node = xmlIterationCount
    text = xmlPrettyPrint(node)
    pr(text)

def xmlOutputComplete():
    global xmlIterationCount
    xmlIterationCount = None

def xmlSetText(node, text, *attrs):
    node.text = str(text)

def noAction(*args, **kwargs):
    pass

#
# Function pointers for each format
#

class FormatNode:
    def __init__(self, parent, name, text, *attrs):
        self.parent = parent
        self.name = name
        self.text = text
        self.attrs = attrs
    def output(self, currentIteration):
        pass
    def outputComplete(self):
        pass
    def setText(self, text):
        self.text = text

class ListFormatNode(FormatNode):
    def __init__(self, parent, name, text, *attrs):
        super().__init__(parent, name, text, *attrs)
        if parent:
            parent = parent.node
        self.node = listNode(parent, name, text, *attrs)
    def output(self, currentIteration):
        listOutputNode(self.node, currentIteration)
    def setText(self, text):
        super().setText(text)
        listSetText(self.node, text, *self.attrs)

class XMLFormatNode(FormatNode):
    def __init__(self, parent, name, text, *attrs):
        super().__init__(parent, name, text, *attrs)
        if parent:
            parent = parent.node
        self.node = xmlNode(parent, name, text, *attrs)
    def output(self, currentIteration):
        xmlOutputNode(self.node, currentIteration)
    def outputComplete(self):
        xmlOutputComplete()
    def setText(self, text):
        super().setText(text)
        xmlSetText(self.node, text, *self.attrs)

class TableFormatNode(FormatNode):
    def __init__(self, parent, name, text, *attrs):
        super().__init__(parent, name, text, *attrs)
        if parent:
            parent = parent.node
        self.node = tableNode(parent, name, text, *attrs)
    def output(self, currentIteration):
        tableOutputNode(self.node, currentIteration)
    def outputComplete(self):
        tableOutputComplete()
    def setText(self, text):
        super().setText(text)
        tableSetText(self.node, text, *self.attrs)

class CSVFormatNode(FormatNode):
    def __init__(self, parent, name, text, *attrs):
        super().__init__(parent, name, text, *attrs)
        if parent:
            parent = parent.node
        self.node = tableNode(parent, name, text, *attrs)
    def output(self, currentIteration):
        csvOutputNode(self.node, currentIteration)
    def setText(self, text):
        super().setText(text)
        tableSetText(self.node, text, *self.attrs)

formatArgClass = { "list" : ListFormatNode, "xml" : XMLFormatNode,
                   "table" : TableFormatNode, "csv" : CSVFormatNode }
formatExtClass = { ".xml" : XMLFormatNode, ".csv" : CSVFormatNode }

# Currently-selected Node class
Node = ListFormatNode

#
# ZE common support
#

def resultString(result):
    results = { ZE_RESULT_SUCCESS : "SUCCESS",
                ZE_RESULT_NOT_READY : "NOT_READY",
                ZE_RESULT_ERROR_DEVICE_LOST : "ERROR_DEVICE_LOST",
                ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY : "ERROR_OUT_OF_HOST_MEMORY",
                ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY : "ERROR_OUT_OF_DEVICE_MEMORY",
                ZE_RESULT_ERROR_MODULE_BUILD_FAILURE : "ERROR_MODULE_BUILD_FAILURE",
                ZE_RESULT_ERROR_MODULE_LINK_FAILURE : "ERROR_LINK_FAILURE",
                ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS : "ERROR_INSUFFICIENT_PERMISSIONS",
                ZE_RESULT_ERROR_NOT_AVAILABLE : "ERROR_NOT_AVAILABLE",
                ZE_RESULT_ERROR_DEPENDENCY_UNAVAILABLE : "ERROR_DEPENDENCY_UNAVAILABLE",
                ZE_RESULT_ERROR_UNINITIALIZED : "ERROR_UNINITIALIZED",
                ZE_RESULT_ERROR_UNSUPPORTED_VERSION : "ERROR_UNSUPPORTED_VERSION",
                ZE_RESULT_ERROR_UNSUPPORTED_FEATURE : "ERROR_UNSUPPORTED_FEATURE",
                ZE_RESULT_ERROR_INVALID_ARGUMENT : "ERROR_INVALID_ARGUMENT",
                ZE_RESULT_ERROR_INVALID_NULL_HANDLE : "ERROR_INVALID_NULL_HANDLE",
                ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE : "ERROR_HANDLE_OBJECT_IN_USE",
                ZE_RESULT_ERROR_INVALID_NULL_POINTER : "ERROR_INVALID_NULL_POINTER",
                ZE_RESULT_ERROR_INVALID_SIZE : "ERROR_INVALID_SIZE",
                ZE_RESULT_ERROR_UNSUPPORTED_SIZE : "ERROR_UNSUPPORTED_SIZE",
                ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT : "ERROR_UNSUPPORTED_ALIGNMENT",
                ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT : "ERROR_INVALID_SYNCHRONIZATION_OBJECT",
                ZE_RESULT_ERROR_INVALID_ENUMERATION : "ERROR_INVALID_ENUMERATION",
                ZE_RESULT_ERROR_UNSUPPORTED_ENUMERATION : "ERROR_UNSUPPORTED_ENUMERATION",
                ZE_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT : "ERROR_UNSUPPORTED_IMAGE_FORMAT",
                ZE_RESULT_ERROR_INVALID_NATIVE_BINARY : "ERROR_INVALID_NATIVE_BINARY",
                ZE_RESULT_ERROR_INVALID_GLOBAL_NAME : "ERROR_INVALID_GLOBAL_NAME",
                ZE_RESULT_ERROR_INVALID_KERNEL_NAME : "ERROR_INVALID_KERNEL_NAME",
                ZE_RESULT_ERROR_INVALID_FUNCTION_NAME : "ERROR_INVALID_FUNCTION_NAME",
                ZE_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION : "ERROR_INVALID_GROUP_SIZE_DIMENSION",
                ZE_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION : "ERROR_INVALID_GLOBAL_WIDTH_DIMENSION",
                ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX : "ERROR_INVALID_KERNEL_ARGUMENT_INDEX",
                ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE : "ERROR_INVALID_KERNEL_ARGUMENT_SIZE",
                ZE_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE : "ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE",
                ZE_RESULT_ERROR_INVALID_MODULE_UNLINKED : "ERROR_MODULE_MUST_BE_UNLINKED",
                ZE_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE : "ERROR_INVALID_COMMAND_LIST_TYPE",
                ZE_RESULT_ERROR_OVERLAPPING_REGIONS : "ERROR_OVERLAPPING_REGIONS",
                ZE_RESULT_ERROR_UNKNOWN : "ERROR_UNKNOWN" }
    return results.get(result, "UNKNOWN")

def default_structure_init(stype, obj):
    obj.stype = stype
    return obj

def ze_typed_structure(stype):
    ctor_map = { ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES : ze_driver_properties_t,
                 ZE_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES : ze_driver_ipc_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES : ze_device_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_COMPUTE_PROPERTIES : ze_device_compute_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_MODULE_PROPERTIES : ze_device_module_properties_t,
                 ZE_STRUCTURE_TYPE_COMMAND_QUEUE_GROUP_PROPERTIES : ze_command_queue_group_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_MEMORY_PROPERTIES : ze_device_memory_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_MEMORY_ACCESS_PROPERTIES : ze_device_memory_access_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_CACHE_PROPERTIES : ze_device_cache_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_IMAGE_PROPERTIES : ze_device_image_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_P2P_PROPERTIES : ze_device_p2p_properties_t,
                 ZE_STRUCTURE_TYPE_CONTEXT_DESC : ze_context_desc_t,
                 ZE_STRUCTURE_TYPE_COMMAND_QUEUE_DESC : ze_command_queue_desc_t,
                 ZE_STRUCTURE_TYPE_COMMAND_LIST_DESC : ze_command_list_desc_t,
                 ZE_STRUCTURE_TYPE_EVENT_POOL_DESC : ze_event_pool_desc_t,
                 ZE_STRUCTURE_TYPE_EVENT_DESC : ze_event_desc_t,
                 ZE_STRUCTURE_TYPE_FENCE_DESC : ze_fence_desc_t,
                 ZE_STRUCTURE_TYPE_IMAGE_DESC : ze_image_desc_t,
                 ZE_STRUCTURE_TYPE_IMAGE_PROPERTIES : ze_image_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC : ze_device_mem_alloc_desc_t,
                 ZE_STRUCTURE_TYPE_HOST_MEM_ALLOC_DESC : ze_host_mem_alloc_desc_t,
                 ZE_STRUCTURE_TYPE_MEMORY_ALLOCATION_PROPERTIES : ze_memory_allocation_properties_t,
                 ZE_STRUCTURE_TYPE_MODULE_DESC : ze_module_desc_t,
                 ZE_STRUCTURE_TYPE_MODULE_PROPERTIES : ze_module_properties_t,
                 ZE_STRUCTURE_TYPE_KERNEL_DESC : ze_kernel_desc_t,
                 ZE_STRUCTURE_TYPE_KERNEL_PROPERTIES : ze_kernel_properties_t,
                 ZE_STRUCTURE_TYPE_SAMPLER_DESC : ze_sampler_desc_t,
                 ZE_STRUCTURE_TYPE_PHYSICAL_MEM_DESC : ze_physical_mem_desc_t }
    init_map = { }

    ctor = ctor_map.get(stype, ze_base_properties_t)
    init = init_map.get(stype, default_structure_init)
    return init(stype, ctor())

def zes_device_properties_init(stype, obj):
    obj = default_structure_init(stype, obj)
    obj.core.stype = ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES
    return obj

def zes_typed_structure(stype):
    ctor_map = { ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES : zes_device_properties_t,
                 ZES_STRUCTURE_TYPE_PCI_PROPERTIES : zes_pci_properties_t,
                 ZES_STRUCTURE_TYPE_PCI_BAR_PROPERTIES : zes_pci_bar_properties_t,
                 ZES_STRUCTURE_TYPE_DIAG_PROPERTIES : zes_diag_properties_t,
                 ZES_STRUCTURE_TYPE_ENGINE_PROPERTIES : zes_engine_properties_t,
                 ZES_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES : zes_fabric_port_properties_t,
                 ZES_STRUCTURE_TYPE_FAN_PROPERTIES : zes_fan_properties_t,
                 ZES_STRUCTURE_TYPE_FIRMWARE_PROPERTIES : zes_firmware_properties_t,
                 ZES_STRUCTURE_TYPE_FREQ_PROPERTIES : zes_freq_properties_t,
                 ZES_STRUCTURE_TYPE_LED_PROPERTIES : zes_led_properties_t,
                 ZES_STRUCTURE_TYPE_MEM_PROPERTIES : zes_mem_properties_t,
                 ZES_STRUCTURE_TYPE_PERF_PROPERTIES : zes_perf_properties_t,
                 ZES_STRUCTURE_TYPE_POWER_PROPERTIES : zes_power_properties_t,
                 ZES_STRUCTURE_TYPE_PSU_PROPERTIES : zes_psu_properties_t,
                 ZES_STRUCTURE_TYPE_RAS_PROPERTIES : zes_ras_properties_t,
                 ZES_STRUCTURE_TYPE_SCHED_PROPERTIES : zes_sched_properties_t,
                 ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES : zes_sched_timeout_properties_t,
                 ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES : zes_sched_timeslice_properties_t,
                 ZES_STRUCTURE_TYPE_STANDBY_PROPERTIES : zes_standby_properties_t,
                 ZES_STRUCTURE_TYPE_TEMP_PROPERTIES : zes_temp_properties_t,
                 ZES_STRUCTURE_TYPE_DEVICE_STATE : zes_device_state_t,
                 ZES_STRUCTURE_TYPE_PROCESS_STATE : zes_process_state_t,
                 ZES_STRUCTURE_TYPE_PCI_STATE : zes_pci_state_t,
                 ZES_STRUCTURE_TYPE_FABRIC_PORT_CONFIG : zes_fabric_port_config_t,
                 ZES_STRUCTURE_TYPE_FABRIC_PORT_STATE : zes_fabric_port_state_t,
                 ZES_STRUCTURE_TYPE_FAN_CONFIG : zes_fan_config_t,
                 ZES_STRUCTURE_TYPE_FREQ_STATE : zes_freq_state_t,
                 ZES_STRUCTURE_TYPE_OC_CAPABILITIES : zes_oc_capabilities_t,
                 ZES_STRUCTURE_TYPE_LED_STATE : zes_led_state_t,
                 ZES_STRUCTURE_TYPE_MEM_STATE : zes_mem_state_t,
                 ZES_STRUCTURE_TYPE_PSU_STATE : zes_psu_state_t,
                 ZES_STRUCTURE_TYPE_BASE_STATE : zes_base_state_t,
                 ZES_STRUCTURE_TYPE_RAS_CONFIG : zes_ras_config_t,
                 ZES_STRUCTURE_TYPE_RAS_STATE : zes_ras_state_t,
                 ZES_STRUCTURE_TYPE_TEMP_CONFIG : zes_temp_config_t }
    init_map = { ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES : zes_device_properties_init }

    ctor = ctor_map.get(stype, zes_base_properties_t)
    init = init_map.get(stype, default_structure_init)
    return init(stype, ctor())

def zes_typed_array(stype, count):
    ctor_map = { ZES_STRUCTURE_TYPE_PCI_BAR_PROPERTIES : zes_pci_bar_properties_array,
                 ZES_STRUCTURE_TYPE_PROCESS_STATE : zes_process_state_array }
    init_map = { }

    # no default array constructor, size must be known:
    array_ctor = ctor_map[stype]
    init = init_map.get(stype, default_structure_init)

    array = array_ctor(count)
    for i in range(count):
        init(stype, array[i])

    return array
#
# Helper
#
def saturate(value, minLimit, maxLimit):
    return min(max(value, minLimit), maxLimit)

if os.environ.get("ZESYSMAN_DEVELOPER_MODE","").upper() == "STUB_API":
    # For stubs to retain state:
    stubState = {}

    def stubzesDeviceEnumTemperatureSensors(dev, count_ptr, handle_array):
        if handle_array is None:
            uint32_assign(count_ptr, 6)
        elif uint32_value(count_ptr) == 6:
            items = zes_temp_handle_array.frompointer(handle_array)
            items[0] = ulong_to_temp_handle(ZES_TEMP_SENSORS_GLOBAL)
            items[1] = ulong_to_temp_handle(ZES_TEMP_SENSORS_GPU)
            items[2] = ulong_to_temp_handle(ZES_TEMP_SENSORS_MEMORY)
            items[3] = ulong_to_temp_handle(ZES_TEMP_SENSORS_GLOBAL_MIN)
            items[4] = ulong_to_temp_handle(ZES_TEMP_SENSORS_GPU_MIN)
            items[5] = ulong_to_temp_handle(ZES_TEMP_SENSORS_MEMORY_MIN)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesTemperatureGetProperties(temp, tempProps):
        t = temp_handle_to_ulong(temp)
        tempProps.type = t
        tempProps.onSubdevice = False
        tempProps.subdeviceId = 0
        tempProps.maxTemperature = 90.0 - 20.0 * t
        tempProps.isCriticalTempSupported = t < ZES_TEMP_SENSORS_GLOBAL_MIN
        tempProps.isThreshold1Supported = t != ZES_TEMP_SENSORS_MEMORY
        tempProps.isThreshold2Supported = t not in [ZES_TEMP_SENSORS_MEMORY, ZES_TEMP_SENSORS_MEMORY_MIN]
    def stubzesTemperatureGetConfig(temp, tempCfg):
        global stubState
        t = temp_handle_to_ulong(temp)
        temps = stubState.setdefault("TempConfig", {})
        cfg = temps.get(t, ( False, ( False, False, 50.0 ), ( False, False, 50.0 ) ))
        tempCfg.enableCritical, t1cfg, t2cfg = cfg
        t1 = tempCfg.threshold1
        t1.enableLowToHigh, t1.enableHighToLow, t1.threshold = t1cfg
        tempCfg.threshold1 = t1
        t2 = tempCfg.threshold2
        t2.enableLowToHigh, t2.enableHighToLow, t2.threshold = t2cfg
        tempCfg.threshold2 = t2
    def stubzesTemperatureSetConfig(temp, tempCfg):
        global stubState
        t = temp_handle_to_ulong(temp)
        temps = stubState.setdefault("TempConfig", {})
        temps[t] = ( tempCfg.enableCritical,
                     ( tempCfg.threshold1.enableLowToHigh, tempCfg.threshold1.enableHighToLow,
                       tempCfg.threshold1.threshold),
                     ( tempCfg.threshold2.enableLowToHigh, tempCfg.threshold2.enableHighToLow,
                       tempCfg.threshold2.threshold) )
    def stubzesTemperatureGetState(temp):
        global stubState
        t = stubState.get("Temp", 50.0)
        stubState["Temp"] = t + 0.1
        return t
    def stubzesDeviceEnumPowerDomains(dev, count_ptr, handle_array):
        global stubState
        if handle_array is None:
            uint32_assign(count_ptr, 1)
        elif uint32_value(count_ptr) == 1:
            p = stubState.setdefault("Pwr", {})
            p["sustained"] = { "enabled" : True, "power" : 100000, "interval" : 1000 }
            p["burst"] = { "enabled" : True, "power" : 150000 }
            p["peak"] = { "powerAC" : 120000, "powerDC" : 90000 }
            p["counter"] = { "energy" : 0, "timestamp" : 0 }
            p["threshold"] = { "threshold" : 0.0, "process" : 0xffffffff }
            items = zes_pwr_handle_array.frompointer(handle_array)
            items[0] = ulong_to_pwr_handle(0)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesPowerGetProperties(pwr, pwrProps):
        pwrProps.onSubdevice = False
        pwrProps.canControl = True
        pwrProps.isEnergyThresholdSupported = True
        pwrProps.defaultLimit = -1
        pwrProps.minLimit = 20
        pwrProps.maxLimit = 200000
    def stubzesPowerSetLimits(pwr, sustainedLimit, burstLimit, peakLimit):
        global stubState
        p = stubState["Pwr"]
        if sustainedLimit is not None:
            p["sustained"]["enabled"] = sustainedLimit.enabled
            p["sustained"]["power"] = sustainedLimit.power
            p["sustained"]["interval"] = sustainedLimit.interval
        if burstLimit is not None:
            p["burst"]["enabled"] = burstLimit.enabled
            p["burst"]["power"] = burstLimit.power
        if peakLimit is not None:
            p["peak"]["powerAC"] = peakLimit.powerAC
            p["peak"]["powerDC"] = peakLimit.powerDC
    def stubzesPowerGetLimits(pwr, sustainedLimit, burstLimit, peakLimit):
        global stubState
        p = stubState["Pwr"]
        if sustainedLimit is not None:
            sustainedLimit.enabled = p["sustained"]["enabled"]
            sustainedLimit.power = p["sustained"]["power"]
            sustainedLimit.interval = p["sustained"]["interval"]
        if burstLimit is not None:
            burstLimit.enabled = p["burst"]["enabled"]
            burstLimit.power = p["burst"]["power"]
        if peakLimit is not None:
            peakLimit.powerAC = p["peak"]["powerAC"]
            peakLimit.powerDC = p["peak"]["powerDC"]
    def stubzesPowerGetEnergyCounter(pwr, pwrCounter):
        global stubState
        p = stubState["Pwr"]
        p["counter"]["energy"] += 100000000
        p["counter"]["timestamp"] += 1000000
        pwrCounter.energy = p["counter"]["energy"]
        pwrCounter.timestamp = p["counter"]["timestamp"]
    def stubzesPowerGetEnergyThreshold(pwr, pwrThreshold):
        global stubState
        p = stubState["Pwr"]
        pwrThreshold.enable = p["threshold"]["threshold"] != 0.0
        pwrThreshold.threshold = p["threshold"]["threshold"]
        pwrThreshold.processId = p["threshold"]["process"]
    def stubzesPowerSetEnergyThreshold(pwr, threshold):
        global stubState
        p = stubState["Pwr"]
        p["threshold"]["threshold"] = threshold
        p["threshold"]["process"] = os.getpid()
    def stubzesDeviceEnumFrequencyDomains(dev, count_ptr, handle_array):
        global stubState
        if handle_array is None:
            uint32_assign(count_ptr, 2)
        elif uint32_value(count_ptr) == 2:
            p = stubState.setdefault("Freq", {})
            p[ZES_FREQ_DOMAIN_GPU] = { "Range" : (200.0, 1200.0),
                                       "State" : 300.0,
                                       "Throttled" : [0, 0],
                                       "ocFreq" : 1200.0,
                                       "ocVolt" : (3.0, 0.0),
                                       "ocMode" : ZES_OC_MODE_OFF,
                                       "iccMax" : 15.0,
                                       "tjMax" : 150.0 }
            p[ZES_FREQ_DOMAIN_MEMORY] = { "Range" : (200.0, 1200.0),
                                          "State" : 300.0,
                                          "Throttled" : [0, 0] }
            items = zes_freq_handle_array.frompointer(handle_array)
            items[0] = ulong_to_freq_handle(ZES_FREQ_DOMAIN_GPU)
            items[1] = ulong_to_freq_handle(ZES_FREQ_DOMAIN_MEMORY)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesFrequencyGetProperties(freq, freqProp):
        freqProp.type = freq_handle_to_ulong(freq)
        freqProp.onSubdevice = False
        freqProp.subdeviceId = 0
        freqProp.canControl = True
        freqProp.isThrottleEventSupported = False
        freqProp.min = 200.0
        freqProp.max = 1200.0
    def stubzesFrequencyGetAvailableClocks(freq, count_ptr, freq_array):
        freqProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FREQ_PROPERTIES)
        zeCall(zesFrequencyGetProperties(freq, freqProps))
        freqs = []
        freq = freqProps.min
        while freq <= freqProps.max:
            freqs.append(freq)
            freq += 50.0
        if freq_array is None:
            uint32_assign(count_ptr, len(freqs))
        elif uint32_value(count_ptr) == len(freqs):
            results = double_array.frompointer(freq_array)
            for i in range(len(freqs)):
                results[i] = freqs[i]
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesFrequencyGetRange(freq, freqLimits):
        global stubState
        f = freq_handle_to_ulong(freq)
        freqLimits.min, freqLimits.max = stubState["Freq"][f]["Range"]
    def stubzesFrequencySetRange(freq, freqLimits):
        global stubState
        f = freq_handle_to_ulong(freq)
        minLimit = saturate(freqLimits.min, 200.0, 1200.0)
        maxLimit = saturate(freqLimits.max, 200.0, 1200.0)
        stubState["Freq"][f]["Range"] = minLimit, maxLimit
    def stubzesFrequencyGetState(freq, freqState):
        global stubState
        f = freq_handle_to_ulong(freq)
        freqState.currentVoltage = 3.0
        freqState.request = stubState["Freq"][f]["State"]
        freqState.tdp = 1200.0
        freqState.efficient = 1000.0
        freqState.actual = stubState["Freq"][f]["State"]
        freqState.throttleReasons = 0
    def stubzesFrequencyGetThrottleTime(freq, freqThrottle):
        global stubState
        f = freq_handle_to_ulong(freq)
        freqThrottle.throttleTime, freqThrottle.timestamp = stubState["Freq"][f]["Throttled"]
        stubState["Freq"][f]["Throttled"][0] += 100000
        stubState["Freq"][f]["Throttled"][1] += 1000000
    def stubzesFrequencyOcGetCapabilities(freq, ocCapabilities):
        global stubState
        f = freq_handle_to_ulong(freq)
        if f == 0:
            ocCapabilities.isOcSupported = True
            ocCapabilities.maxFactoryDefaultFrequency = 300.0
            ocCapabilities.maxFactoryDefaultVoltage = 3.0
            ocCapabilities.maxOcFrequency = 2000
            ocCapabilities.minOcVoltageOffset = 0.5
            ocCapabilities.maxOcVoltageOffset = 1.5
            ocCapabilities.maxOcVoltage = 5.0
            ocCapabilities.isTjMaxSupported = True
            ocCapabilities.isIccMaxSupported = True
            ocCapabilities.isHighVoltModeCapable = True
            ocCapabilities.isHighVoltModeEnabled = False
            ocCapabilities.isExtendedModeSupported = True
            ocCapabilities.isFixedModeSupported = True
        elif f == 1:
            ocCapabilities.isOcSupported = False
            ocCapabilities.maxFactoryDefaultFrequency = 300.0
            ocCapabilities.maxFactoryDefaultVoltage = 3.0
            ocCapabilities.maxOcFrequency = 1200
            ocCapabilities.minOcVoltageOffset = 0.0
            ocCapabilities.maxOcVoltageOffset = 0.0
            ocCapabilities.maxOcVoltage = 3.0
            ocCapabilities.isTjMaxSupported = False
            ocCapabilities.isIccMaxSupported = False
            ocCapabilities.isHighVoltModeCapable = False
            ocCapabilities.isHighVoltModeEnabled = False
            ocCapabilities.isExtendedModeSupported = False
            ocCapabilities.isFixedModeSupported = False
        else:
            raise ValueError(f)
    def stubzesFrequencyOcGetFrequencyTarget(freq):
        global stubState
        f = freq_handle_to_ulong(freq)
        if f == 0:
            return stubState["Freq"][f]["ocFreq"]
        else:
            raise ValueError(f)
    def stubzesFrequencyOcSetFrequencyTarget(freq, ocFTarget):
        global stubState
        f = freq_handle_to_ulong(freq)
        if f == 0:
            stubState["Freq"][f]["ocFreq"] = ocFTarget
        else:
            raise ValueError(f)
    def stubzesFrequencyOcGetVoltageTarget(freq):
        global stubState
        f = freq_handle_to_ulong(freq)
        if f == 0:
            return stubState["Freq"][f]["ocVolt"]
        else:
            raise ValueError(f)
    def stubzesFrequencyOcSetVoltageTarget(freq, ocVTarget, ocVOffset):
        global stubState
        f = freq_handle_to_ulong(freq)
        if f == 0:
            stubState["Freq"][f]["ocVolt"] = (ocVTarget, ocVOffset)
        else:
            raise ValueError(f)
    def stubzesFrequencyOcSetMode(freq, ocMode):
        global stubState
        f = freq_handle_to_ulong(freq)
        if f == 0:
            stubState["Freq"][f]["ocMode"] = ocMode
        else:
            raise ValueError(f)
    def stubzesFrequencyOcGetMode(freq):
        global stubState
        f = freq_handle_to_ulong(freq)
        if f == 0:
            return stubState["Freq"][f]["ocMode"]
        else:
            return ZES_OC_MODE_OFF
    def stubzesFrequencyOcGetIccMax(freq):
        global stubState
        f = freq_handle_to_ulong(freq)
        if f == 0:
            return stubState["Freq"][f]["iccMax"]
        else:
            raise ValueError(f)
    def stubzesFrequencyOcSetIccMax(freq, ocIccMax):
        global stubState
        f = freq_handle_to_ulong(freq)
        if f == 0:
            stubState["Freq"][f]["iccMax"] = ocIccMax
        else:
            raise ValueError(f)
    def stubzesFrequencyOcGetTjMax(freq):
        global stubState
        f = freq_handle_to_ulong(freq)
        if f == 0:
            return stubState["Freq"][f]["tjMax"]
        else:
            raise ValueError(f)
    def stubzesFrequencyOcSetTjMax(freq, ocTjMax):
        global stubState
        f = freq_handle_to_ulong(freq)
        if f == 0:
            stubState["Freq"][f]["tjMax"] = ocTjMax
        else:
            raise ValueError(f)
    def stubzesDeviceEnumEngineGroups(dev, count_ptr, handle_array):
        global stubState
        if handle_array is None:
            uint32_assign(count_ptr, 9)
        elif uint32_value(count_ptr) == 9:
            e = stubState.setdefault("Engine", {})
            e[ZES_ENGINE_GROUP_ALL] = { "activeTime" : 0, "timestamp" : 0 }
            e[ZES_ENGINE_GROUP_COMPUTE_ALL] = { "activeTime" : 0, "timestamp" : 0 }
            e[ZES_ENGINE_GROUP_MEDIA_ALL] = { "activeTime" : 0, "timestamp" : 0 }
            e[ZES_ENGINE_GROUP_COPY_ALL] = { "activeTime" : 0, "timestamp" : 0 }
            e[ZES_ENGINE_GROUP_COMPUTE_SINGLE] = { "activeTime" : 0, "timestamp" : 0 }
            e[ZES_ENGINE_GROUP_RENDER_SINGLE] = { "activeTime" : 0, "timestamp" : 0 }
            e[ZES_ENGINE_GROUP_MEDIA_DECODE_SINGLE] = { "activeTime" : 0, "timestamp" : 0 }
            e[ZES_ENGINE_GROUP_MEDIA_ENCODE_SINGLE] = { "activeTime" : 0, "timestamp" : 0 }
            e[ZES_ENGINE_GROUP_COPY_SINGLE] = { "activeTime" : 0, "timestamp" : 0 }
            items = zes_engine_handle_array.frompointer(handle_array)
            items[0] = ulong_to_engine_handle(ZES_ENGINE_GROUP_ALL)
            items[1] = ulong_to_engine_handle(ZES_ENGINE_GROUP_COMPUTE_ALL)
            items[2] = ulong_to_engine_handle(ZES_ENGINE_GROUP_MEDIA_ALL)
            items[3] = ulong_to_engine_handle(ZES_ENGINE_GROUP_COPY_ALL)
            items[4] = ulong_to_engine_handle(ZES_ENGINE_GROUP_COMPUTE_SINGLE)
            items[5] = ulong_to_engine_handle(ZES_ENGINE_GROUP_RENDER_SINGLE)
            items[6] = ulong_to_engine_handle(ZES_ENGINE_GROUP_MEDIA_DECODE_SINGLE)
            items[7] = ulong_to_engine_handle(ZES_ENGINE_GROUP_MEDIA_ENCODE_SINGLE)
            items[8] = ulong_to_engine_handle(ZES_ENGINE_GROUP_COPY_SINGLE)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesEngineGetProperties(eng, engProps):
        engProps.type = engine_handle_to_ulong(eng)
    def stubzesEngineGetActivity(eng, utilStats):
        global stubState
        e = stubState["Engine"]
        etype = engine_handle_to_ulong(eng)
        stats = e[etype]
        stats["timestamp"] += 1000000
        if etype == ZES_ENGINE_GROUP_ALL:
            stats["activeTime"] += 700000
        if etype == ZES_ENGINE_GROUP_COMPUTE_ALL:
            stats["activeTime"] += 500000
        if etype == ZES_ENGINE_GROUP_MEDIA_ALL:
            stats["activeTime"] += 150000
        if etype == ZES_ENGINE_GROUP_COPY_ALL:
            stats["activeTime"] += 50000
        if etype == ZES_ENGINE_GROUP_COMPUTE_SINGLE:
            stats["activeTime"] += 300000
        if etype == ZES_ENGINE_GROUP_RENDER_SINGLE:
            stats["activeTime"] += 200000
        if etype == ZES_ENGINE_GROUP_MEDIA_DECODE_SINGLE:
            stats["activeTime"] += 30000
        if etype == ZES_ENGINE_GROUP_MEDIA_ENCODE_SINGLE:
            stats["activeTime"] += 120000
        if etype == ZES_ENGINE_GROUP_COPY_SINGLE:
            stats["activeTime"] += 50000
        utilStats.timestamp = stats["timestamp"]
        utilStats.activeTime = stats["activeTime"]
    def stubzesDevicePciGetProperties(dev, pciProps):
        pciProps.address.domain = 1
        pciProps.address.bus = 2
        pciProps.address.device = 3
        pciProps.address.function = 4
        pciProps.maxSpeed.gen = 4
        pciProps.maxSpeed.width = 16
        pciProps.maxSpeed.maxBandwidth = -1
        pciProps.haveBandwidthCounters = True
        pciProps.havePacketCounters = True
        pciProps.haveReplayCounters = True
    def stubzesDevicePciGetState(dev, pciState):
        pciState.status = ZES_PCI_LINK_STATUS_GOOD
        pciState.qualityIssues = 0
        pciState.stabilityIssues = 0
        pciState.speed.gen = 4
        pciState.speed.width = 4
        pciState.speed.maxBandwidth = 7880000000
    def stubzesDevicePciGetStats(dev, pciCounter):
        global stubState
        devs = stubState.setdefault("Devices", {})
        d = devs.setdefault(device_handle_to_ulong(dev), {})
        r = d.setdefault("PCIstats", [0,0,0,0,0])
        pciCounter.timestamp = r[0]
        pciCounter.replayCounter = r[1]
        pciCounter.packetCounter = r[2]
        pciCounter.rxCounter = r[3]
        pciCounter.txCounter = r[4]
        r[0] += 1000000
        r[1] += 10
        r[2] += 1000
        r[3] += 788000000
        r[4] += 78800000
        pciCounter.speed.gen = 4
        pciCounter.speed.width = 4
        pciCounter.speed.maxBandwidth = 7880000000
    def stubzesDevicePciGetBars(dev, count_ptr, handle_array):
        if handle_array is None:
            uint32_assign(count_ptr, 3)
        elif uint32_value(count_ptr) == 3:
            items = zes_pci_bar_properties_array.frompointer(handle_array)
            item = items[0]
            item.type = ZES_PCI_BAR_TYPE_MMIO
            item.index = 0
            item.base = 0x0000400000000000
            item.size = 0x0000000000010000
            items[0] = item
            item = items[1]
            item.type = ZES_PCI_BAR_TYPE_ROM
            item.index = 1
            item.base = 0x0000400000080000
            item.size = 0x0000000000080000
            items[1] = item
            item = items[2]
            item.type = ZES_PCI_BAR_TYPE_MEM
            item.index = 2
            item.base = 0x0000400000100000
            item.size = 0x0000000000300000
            items[2] = item
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesDeviceEnumDiagnosticTestSuites(dev, count_ptr, handle_array):
        if handle_array is None:
            uint32_assign(count_ptr, 2)
        elif uint32_value(count_ptr) == 2:
            items = zes_diag_handle_array.frompointer(handle_array)
            items[0] = ulong_to_diag_handle(0)
            items[1] = ulong_to_diag_handle(1)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesDiagnosticsGetProperties(diag, diagProps):
        diagProps.onSubdevice = False
        suite = diag_handle_to_ulong(diag)
        if suite == 0:
            diagProps.name = "ARRAY"
            diagProps.haveTests = True
        elif suite == 1:
            diagProps.name = "SCAN"
            diagProps.haveTests = False
        else:
            raise ValueError(suite)
    def stubzesDiagnosticsGetTests(diag, count_ptr, tests_array):
        suite = diag_handle_to_ulong(diag)
        if suite == 0:
            if tests_array is None:
                uint32_assign(count_ptr, 3)
            elif uint32_value(count_ptr) == 3:
                tests = zes_diag_test_array.frompointer(tests_array)
                test = tests[0]
                test.index = 65
                test.name = "A"
                tests[0] = test
                test = tests[1]
                test.index = 77
                test.name = "M"
                tests[1] = test
                test = tests[2]
                test.index = 80
                test.name = "P"
                tests[2] = test
            else:
                raise ValueError(uint32_value(count_ptr))
        elif suite == 1:
            if tests_array is None:
                uint32_assign(count_ptr, 0)
            elif uint32_value(count_ptr) != 0:
                raise ValueError(uint32_value(count_ptr))
        else:
            raise ValueError(suite)
    def stubzesDiagnosticsRunTests(diag, first, last):
        suite = diag_handle_to_ulong(diag)
        if suite == 0:
            result = ZES_DIAG_RESULT_ABORT
            if first <= 65 and last >= 65:
                result = ZES_DIAG_RESULT_NO_ERRORS
            if first <= 77 and last >= 77:
                result = ZES_DIAG_RESULT_REBOOT_FOR_REPAIR
            if first <= 80 and last >= 80:
                result = ZES_DIAG_RESULT_FAIL_CANT_REPAIR
            return result
        elif suite == 1:
            return ZES_DIAG_RESULT_NO_ERRORS
        else:
            raise ValueError(suite)
    def stubzesDeviceEventRegister(dev, events):
        global stubState
        devs = stubState.setdefault("Devices", {})
        d = devs.setdefault(device_handle_to_ulong(dev), {})
        d["EventEnables"] = events
    def stubzesDriverEventListen(drv, timeout, count, device_array, event_array):
        global stubState
        devs = stubState.setdefault("Devices", {})
        devices = ze_device_handle_array.frompointer(device_array)
        events = zes_event_type_flags_array.frompointer(event_array)
        for i in range(count):
            dev = devices[i]
            d = devs.setdefault(device_handle_to_ulong(dev), {})
            enables = d.setdefault("EventEnables", 0)
            events[i] = enables & (ZES_EVENT_TYPE_FLAG_FABRIC_PORT_HEALTH |
                                   ZES_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS |
                                   ZES_EVENT_TYPE_FLAG_DEVICE_RESET_REQUIRED)
        return count
    def stubzesDeviceEnumFabricPorts(dev, count_ptr, handle_array):
        global stubState
        if handle_array is None:
            uint32_assign(count_ptr, 10)
        elif uint32_value(count_ptr) == 10:
            nextFabricId = stubState.setdefault("NextFabricId", 0)
            devs = stubState.setdefault("Devices", {})
            d = devs.setdefault(device_handle_to_ulong(dev), {})
            fabricId = d.setdefault("FabricId", nextFabricId)
            if fabricId == nextFabricId:
                stubState["NextFabricId"] += 1
            items = zes_fabric_port_handle_array.frompointer(handle_array)
            for i in range(10):
                items[i] = ulong_to_fabric_port_handle(fabricId * 10 + i)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesFabricPortGetProperties(port, portProps):
        global stubState
        p = fabric_port_handle_to_ulong(port)
        fabricId = p // 10
        localIdx = p % 10
        portProps.model = "ANR"
        portProps.onSubDevice = True
        portProps.subdeviceId = localIdx // 5
        portProps.portId.fabricId = fabricId
        portProps.portId.attachId = localIdx // 5
        portProps.portId.portNumber = localIdx % 5
        portProps.maxRxSpeed.bitRate = 1000000000
        portProps.maxRxSpeed.width = 8
        portProps.maxTxSpeed.bitRate = 1000000000
        portProps.maxTxSpeed.width = 8
    def stubzesFabricPortGetLinkType(port, linkType):
        linkType.desc = "ANR"
    def stubzesFabricPortGetConfig(port, portConfig):
        global stubState
        p = fabric_port_handle_to_ulong(port)
        ports = stubState.setdefault("FabricPortConfig", {})
        portConfig.enabled, portConfig.beaconing = ports.setdefault(p, (True, False))
    def stubzesFabricPortSetConfig(port, portConfig):
        global stubState
        p = fabric_port_handle_to_ulong(port)
        ports = stubState.setdefault("FabricPortConfig", {})
        ports[p] = (portConfig.enabled, portConfig.beaconing)
    def stubzesFabricPortGetState(port, portState):
        global stubState
        p = fabric_port_handle_to_ulong(port)
        ports = stubState.setdefault("FabricPortConfig", {})
        enabled, _ = ports.setdefault(p, (True, False))
        fabricId = p // 10
        localIdx = p % 10
        portState.qualityIssues = 0
        portState.failureReasons = 0
        if enabled:
            if localIdx == 0:
                portState.status = ZES_FABRIC_PORT_STATUS_UNKNOWN
            elif localIdx == 1:
                portState.status = ZES_FABRIC_PORT_STATUS_HEALTHY
            elif localIdx == 2:
                portState.status = ZES_FABRIC_PORT_STATUS_DEGRADED
                portState.qualityIssues = ZES_FABRIC_PORT_QUAL_ISSUE_FLAG_LINK_ERRORS
            elif localIdx == 3:
                portState.status = ZES_FABRIC_PORT_STATUS_DEGRADED
                portState.qualityIssues = ZES_FABRIC_PORT_QUAL_ISSUE_FLAG_SPEED
            elif localIdx == 4:
                portState.status = ZES_FABRIC_PORT_STATUS_DEGRADED
                portState.qualityIssues = (ZES_FABRIC_PORT_QUAL_ISSUE_FLAG_LINK_ERRORS |
                                           ZES_FABRIC_PORT_QUAL_ISSUE_FLAG_SPEED)
            elif localIdx == 5:
                portState.status = ZES_FABRIC_PORT_STATUS_FAILED
                portState.failureReasons = (ZES_FABRIC_PORT_FAILURE_FLAG_TRAINING_TIMEOUT |
                                            ZES_FABRIC_PORT_FAILURE_FLAG_FAILED)
            elif localIdx == 6:
                portState.status = ZES_FABRIC_PORT_STATUS_FAILED
                portState.failureReasons = (ZES_FABRIC_PORT_FAILURE_FLAG_FLAPPING |
                                            ZES_FABRIC_PORT_FAILURE_FLAG_FAILED)
            elif localIdx == 7:
                portState.status = ZES_FABRIC_PORT_STATUS_FAILED
                portState.failureReasons = ZES_FABRIC_PORT_FAILURE_FLAG_TRAINING_TIMEOUT
            elif localIdx == 8:
                portState.status = ZES_FABRIC_PORT_STATUS_FAILED
                portState.failureReasons = ZES_FABRIC_PORT_FAILURE_FLAG_FLAPPING
            else:
                portState.status = ZES_FABRIC_PORT_STATUS_FAILED
                portState.failureReasons = ZES_FABRIC_PORT_FAILURE_FLAG_FAILED
        else:
            portState.status = ZES_FABRIC_PORT_STATUS_DISABLED
        portState.remotePortId.fabricId = fabricId ^ 1
        portState.remotePortId.attachId = localIdx // 5
        portState.remotePortId.portNumber = localIdx % 5
        portState.rxSpeed.bitRate = 1000000000
        portState.rxSpeed.width = 8
        portState.txSpeed.bitRate = 1000000000
        portState.txSpeed.width = 8
    def stubzesFabricPortGetThroughput(port, portThroughput):
        global stubState
        p = fabric_port_handle_to_ulong(port)
        ports = stubState.setdefault("FabricPortThroughput", {})
        r = ports.setdefault(p, [0,0,0])
        portThroughput.timestamp = r[0]
        portThroughput.rxCounter = r[1]
        portThroughput.txCounter = r[2]
        r[0] += 1000000
        r[1] += 1000000000
        r[2] += 900000000
    def stubzesDeviceEnumRasErrorSets(dev, count_ptr, handle_array):
        global stubState
        stubState.setdefault("RasErrors", {ZES_RAS_ERROR_TYPE_CORRECTABLE : [2, 0, 0, 0, 0, 0, 3],
                                           ZES_RAS_ERROR_TYPE_UNCORRECTABLE : [1, 0, 0, 0, 0, 0, 1]})
        stubState.setdefault("RasThresh", {ZES_RAS_ERROR_TYPE_CORRECTABLE : [2, 3, 1, 0, 0, 0, 0, 9],
                                           ZES_RAS_ERROR_TYPE_UNCORRECTABLE : [1, 0, 1, 2, 3, 1, 0, 5]})
        if handle_array is None:
            uint32_assign(count_ptr, 2)
        elif uint32_value(count_ptr) == 2:
            items = zes_ras_handle_array.frompointer(handle_array)
            items[0] = ulong_to_ras_handle(ZES_RAS_ERROR_TYPE_CORRECTABLE)
            items[1] = ulong_to_ras_handle(ZES_RAS_ERROR_TYPE_UNCORRECTABLE)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesRasGetProperties(ras, rasProps):
        rasProps.type = ras_handle_to_ulong(ras)
        rasProps.onSubdevice = False
        rasProps.subdeviceId = 0
    def stubzesRasGetConfig(ras, rasConfig):
        global stubState
        r = ras_handle_to_ulong(ras)
        thresholds = stubState["RasThresh"][r]
        rasConfig.totalThreshold = thresholds[ZES_MAX_RAS_ERROR_CATEGORY_COUNT]
        for i in range(ZES_MAX_RAS_ERROR_CATEGORY_COUNT):
            ras_category_set(rasConfig.detailedThresholds, i, thresholds[i])
    def stubzesRasSetConfig(ras, rasConfig):
        global stubState
        r = ras_handle_to_ulong(ras)
        thresholds = stubState["RasThresh"][r]
        thresholds[ZES_MAX_RAS_ERROR_CATEGORY_COUNT] = rasConfig.totalThreshold
        for i in range(ZES_MAX_RAS_ERROR_CATEGORY_COUNT):
            thresholds[i] = ras_category(rasConfig.detailedThresholds, i)
    def stubzesRasGetState(ras, clearErrors, rasState):
        global stubState
        r = ras_handle_to_ulong(ras)
        if clearErrors:
            stubState["RasErrors"][r] = [0, 0, 0, 0, 0, 0, 0]
        if rasState is not None:
            errors = stubState["RasErrors"][r]
            for i in range(ZES_MAX_RAS_ERROR_CATEGORY_COUNT):
                ras_category_set(rasState, i, errors[i])
                errors[i] += (i + 1)
    def stubzesDeviceProcessesGetState(dev, count_ptr, proc_array):
        if proc_array is None:
            uint32_assign(count_ptr, 4)
        elif uint32_value(count_ptr) == 4:
            procs = zes_process_state_array.frompointer(proc_array)
            proc = procs[0]
            proc.processId = 32765
            proc.memSize = 0x10000
            proc.sharedSize = 0x1000
            proc.engines = 1 << ZES_ENGINE_TYPE_FLAG_OTHER | 1 << ZES_ENGINE_TYPE_FLAG_COMPUTE
            procs[0] = proc
            proc = procs[1]
            proc.processId = 32766
            proc.memSize = 0x20000
            proc.sharedSize = 0x1000
            proc.engines = 1 << ZES_ENGINE_TYPE_FLAG_3D
            procs[1] = proc
            proc = procs[2]
            proc.processId = 32767
            proc.memSize = 0x30000
            proc.sharedSize = 0x1000
            proc.engines = 1 << ZES_ENGINE_TYPE_FLAG_MEDIA | 1 << ZES_ENGINE_TYPE_FLAG_DMA
            procs[2] = proc
            proc = procs[3]
            proc.processId = 32768
            proc.memSize = 0x40000
            proc.sharedSize = 0x1000
            proc.engines = (1 << ZES_ENGINE_TYPE_FLAG_OTHER | 1 << ZES_ENGINE_TYPE_FLAG_COMPUTE |
                            1 << ZES_ENGINE_TYPE_FLAG_3D | 1 << ZES_ENGINE_TYPE_FLAG_MEDIA |
                            1 << ZES_ENGINE_TYPE_FLAG_DMA)
            procs[3] = proc
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesDeviceEnumFans(dev, count_ptr, handle_array):
        if handle_array is None:
            uint32_assign(count_ptr, 2)
        elif uint32_value(count_ptr) == 2:
            items = zes_fan_handle_array.frompointer(handle_array)
            items[0] = ulong_to_fan_handle(0)
            items[1] = ulong_to_fan_handle(1)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesFanSetDefaultMode(fan):
        global stubState
        f = fan_handle_to_ulong(fan)
        fanModes = stubState.setdefault("FanMode", {})
        fanModes[f] = ZES_FAN_SPEED_MODE_DEFAULT
    def stubzesFanSetFixedSpeedMode(fan, speed):
        global stubState
        f = fan_handle_to_ulong(fan)
        fanModes = stubState.setdefault("FanMode", {})
        fanModes[f] = ZES_FAN_SPEED_MODE_FIXED
        fanSpeeds = stubState.setdefault("FanFixedSpeed", {})
        fanUnits = stubState.setdefault("FanFixedSpeedUnits", {})
        fanSpeeds[f] = speed.speed
        fanUnits[f] = speed.units
    def stubzesFanSetSpeedTableMode(fan, speedTable):
        global stubState
        f = fan_handle_to_ulong(fan)
        fanModes = stubState.setdefault("FanMode", {})
        fanModes[f] = ZES_FAN_SPEED_MODE_TABLE
        fanTables = stubState.setdefault("FanTable", {})
        fanTablePoints = stubState.setdefault("FanTablePoints", {})
        fanTablePoints[f] = speedTable.numPoints
        table = []
        tableSize = speedTable.numPoints
        tempSpeed = zes_fan_temp_speed_array(tableSize)
        fan_speed_table_get(speedTable, tableSize, tempSpeed.cast())
        for t in range(tableSize):
            item = tempSpeed[t]
            entry = (item.temperature, item.speed.speed, item.speed.units)
            table.append(entry)
        fanTables[f] = table
    def stubzesFanGetProperties(fan, fanProps):
        f = fan_handle_to_ulong(fan)
        fanProps.onSubdevice = f > 0
        fanProps.subdeviceId = f
        fanProps.canControl = True
        fanProps.supportedModes = 7
        fanProps.supportedUnits = 3
        fanProps.maxRPM = 10000
        fanProps.maxPoints = 10
    def stubzesFanGetConfig(fan, fanConfig):
        global stubState
        f = fan_handle_to_ulong(fan)
        fanModes = stubState.setdefault("FanMode", {})
        fanConfig.mode = fanModes.setdefault(f, ZES_FAN_SPEED_MODE_DEFAULT)
        if fanConfig.mode == ZES_FAN_SPEED_MODE_FIXED:
            fanSpeeds = stubState.setdefault("FanFixedSpeed", {})
            fanUnits = stubState.setdefault("FanFixedSpeedUnits", {})
            fanConfig.speedFixed.speed = fanSpeeds.setdefault(f, 1000)
            fanConfig.speedFixed.units = fanUnits.setdefault(f, ZES_FAN_SPEED_UNITS_RPM)
        elif fanConfig.mode == ZES_FAN_SPEED_MODE_TABLE:
            fanTables = stubState.setdefault("FanTable", {})
            fanTablePoints = stubState.setdefault("FanTablePoints", {})
            tableSize = fanTablePoints.setdefault(f, 3)
            table = fanTables.setdefault(f, [(50, 1000, ZES_FAN_SPEED_UNITS_RPM),
                                             (100, 5000, ZES_FAN_SPEED_UNITS_RPM),
                                             (150, 10000, ZES_FAN_SPEED_UNITS_RPM)])
            tempSpeed = zes_fan_temp_speed_array(tableSize)
            for t, entry in indexed(table):
                item = tempSpeed[t]
                item.temperature = entry[0]
                item.speed.speed = entry[1]
                item.speed.units = entry[2]
                tempSpeed[t] = item
            # fan_config_speed_table_set(fanConfig, tableSize, tempSpeed)
    def stubzesFanGetState(fan, units):
        global stubState
        f = fan_handle_to_ulong(fan)
        fanModes = stubState.setdefault("FanMode", {})
        mode = fanModes.setdefault(f, ZES_FAN_SPEED_MODE_DEFAULT)
        if mode == ZES_FAN_SPEED_MODE_FIXED:
            fanSpeeds = stubState.setdefault("FanFixedSpeed", {})
            fanUnits = stubState.setdefault("FanFixedSpeedUnits", {})
            current_speed = fanSpeeds.setdefault(f, 1000)
            current_units = fanUnits.setdefault(f, ZES_FAN_SPEED_UNITS_RPM)
        elif mode == ZES_FAN_SPEED_MODE_TABLE:
            fanTables = stubState.setdefault("FanTable", {})
            fanTablePoints = stubState.setdefault("FanTablePoints", {})
            fanTableIndices = stubState.setdefault("FanTableIndices", {})
            numPoints = fanTablePoints.setdefault(f, 3)
            table = fanTables.setdefault(f, [(50, 1000, ZES_FAN_SPEED_UNITS_RPM),
                                             (100, 5000, ZES_FAN_SPEED_UNITS_RPM),
                                             (150, 10000, ZES_FAN_SPEED_UNITS_RPM)])
            idx = fanTableIndices.setdefault(f, 0)
            current_speed = table[idx][1]
            current_units = table[idx][2]
            if units == ZES_FAN_SPEED_UNITS_PERCENT:
                fanTableIndices[f] = (idx + 1) % len(table)
        else:
            current_speed = 2000
            current_units = ZES_FAN_SPEED_UNITS_RPM
        if current_units == units:
            return current_speed
        elif units == ZES_FAN_SPEED_UNITS_RPM:
            return current_speed * 100
        else:
            return current_speed // 100
    def stubzesDeviceEnumFirmwares(dev, count_ptr, handle_array):
        if handle_array is None:
            uint32_assign(count_ptr, 1)
        elif uint32_value(count_ptr) == 1:
            items = zes_firmware_handle_array.frompointer(handle_array)
            items[0] = ulong_to_firmware_handle(0)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesFirmwareGetProperties(fw, fwProps):
        fwProps.onSubdevice = False
        fwProps.subdeviceId = 0
        fwProps.canControl = True
        fwProps.name = "FIRMWARE"
        fwProps.version = "1.0.0"
    def stubzesFirmwareFlashData(handle, image):
        fw = firmware_handle_to_ulong(handle)
        pr("Flashing firmware image", fw, "of size", len(image), ":")
        if image.isascii():
            lines = str(image, 'utf-8').splitlines()
            if len(lines) < 100:
                pr(" " + "\n ".join(lines))
            else:
                pr(" [ascii data, greater than 100 lines]")
        else:
            pr(" [binary data]")
    def stubzesDeviceEnumLeds(dev, count_ptr, handle_array):
        global stubState
        if handle_array is None:
            uint32_assign(count_ptr, 2)
        elif uint32_value(count_ptr) == 2:
            l = stubState.setdefault("Led", {})
            l[0] = { "on" : False, "color" : (1.0, 0.0, 0.0) }
            l[1] = { "on" : False, "color" : (1.0, 0.0, 0.0) }
            items = zes_led_handle_array.frompointer(handle_array)
            items[0] = ulong_to_led_handle(0)
            items[1] = ulong_to_led_handle(1)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesLedGetProperties(led, ledProps):
        global stubState
        l = led_handle_to_ulong(led)
        if l > 1:
            raise ValueError(l)
        ledProps.canControl = True
        ledProps.haveRGB = l==0
    def stubzesLedGetState(led, ledState):
        global stubState
        l = led_handle_to_ulong(led)
        if l > 1:
            raise ValueError(l)
        ledState.isOn = stubState["Led"][l]["on"]
        color = zes_led_color_t()
        color.red,color.green,color.blue = stubState["Led"][l]["color"]
        ledState.color = color
    def stubzesLedSetState(led, enable):
        global stubState
        l = led_handle_to_ulong(led)
        if l > 1:
            raise ValueError(l)
        stubState["Led"][l]["on"] = enable
    def stubzesLedSetColor(led, color):
        global stubState
        l = led_handle_to_ulong(led)
        if l > 1:
            raise ValueError(l)
        stubState["Led"][l]["color"] = color.red,color.green,color.blue
    def stubzesDeviceEnumMemoryModules(dev, count_ptr, handle_array):
        global stubState
        if handle_array is None:
            uint32_assign(count_ptr, 14)
        elif uint32_value(count_ptr) == 14:
            m = stubState.setdefault("Mem", {})
            m[ZES_MEM_TYPE_HBM] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_DDR] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_DDR3] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_DDR4] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_DDR5] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_LPDDR] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_LPDDR3] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_LPDDR4] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_LPDDR5] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_SRAM] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_L1] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_L3] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_GRF] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            m[ZES_MEM_TYPE_SLM] = { "usage" : (1000000000, 1000000000), "bw" : (0, 0, 1000000000, 0) }
            items = zes_mem_handle_array.frompointer(handle_array)
            items[0] = ulong_to_mem_handle(ZES_MEM_TYPE_HBM)
            items[1] = ulong_to_mem_handle(ZES_MEM_TYPE_DDR)
            items[2] = ulong_to_mem_handle(ZES_MEM_TYPE_DDR3)
            items[3] = ulong_to_mem_handle(ZES_MEM_TYPE_DDR4)
            items[4] = ulong_to_mem_handle(ZES_MEM_TYPE_DDR5)
            items[5] = ulong_to_mem_handle(ZES_MEM_TYPE_LPDDR)
            items[6] = ulong_to_mem_handle(ZES_MEM_TYPE_LPDDR3)
            items[7] = ulong_to_mem_handle(ZES_MEM_TYPE_LPDDR4)
            items[8] = ulong_to_mem_handle(ZES_MEM_TYPE_LPDDR5)
            items[9] = ulong_to_mem_handle(ZES_MEM_TYPE_SRAM)
            items[10] = ulong_to_mem_handle(ZES_MEM_TYPE_L1)
            items[11] = ulong_to_mem_handle(ZES_MEM_TYPE_L3)
            items[12] = ulong_to_mem_handle(ZES_MEM_TYPE_GRF)
            items[13] = ulong_to_mem_handle(ZES_MEM_TYPE_SLM)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesMemoryGetProperties(mem, memProps):
        m = mem_handle_to_ulong(mem)
        if m > ZES_MEM_TYPE_SLM:
            raise ValueError(m)
        memProps.type = m
        if m < ZES_MEM_TYPE_LPDDR:
            memProps.onSubdevice = False
        else:
            memProps.onSubdevice = True
        memProps.subdeviceId = 0
        if m < ZES_MEM_TYPE_SRAM:
            memProps.location = ZES_MEM_LOC_SYSTEM
        else:
            memProps.location = ZES_MEM_LOC_DEVICE
        memProps.physicalSize = 2000000000
        memProps.busWidth = 64
        memProps.numChannels = 2
    def stubzesMemoryGetState(mem, memState):
        global stubState
        m = mem_handle_to_ulong(mem)
        memState.health = m % 5
        f, s = stubState["Mem"][m]["usage"]
        memState.free, memState.size = f, s
        f -= 100000000 + m * 10000000
        while f < 0:
            f += s
        stubState["Mem"][m]["usage"] = f, s
    def stubzesMemoryGetBandwidth(mem, memBw):
        global stubState
        m = mem_handle_to_ulong(mem)
        r, w, x, t = stubState["Mem"][m]["bw"]
        memBw.readCounter, memBw.writeCounter, memBw.maxBandwidth, memBw.timestamp = r, w, x, t
        r += 200000000 + m * 10000000
        w += 100000000 + m * 20000000
        t += 1000000
        stubState["Mem"][m]["bw"] = r, w, x, t
    def stubzesDeviceEnumPerformanceFactorDomains(dev, count_ptr, handle_array):
        if handle_array is None:
            uint32_assign(count_ptr, 5)
        elif uint32_value(count_ptr) == 5:
            items = zes_perf_handle_array.frompointer(handle_array)
            items[0] = ulong_to_perf_handle(ZES_ENGINE_TYPE_FLAG_COMPUTE)
            items[1] = ulong_to_perf_handle(ZES_ENGINE_TYPE_FLAG_COMPUTE | ZES_ENGINE_TYPE_FLAG_3D)
            items[2] = ulong_to_perf_handle(ZES_ENGINE_TYPE_FLAG_OTHER | ZES_ENGINE_TYPE_FLAG_MEDIA)
            items[3] = ulong_to_perf_handle(ZES_ENGINE_TYPE_FLAG_OTHER | ZES_ENGINE_TYPE_FLAG_DMA)
            items[4] = ulong_to_perf_handle(ZES_ENGINE_TYPE_FLAG_DMA)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesPerformanceFactorGetProperties(perf, perfProps):
        p = perf_handle_to_ulong(perf)
        perfProps.onSubdevice = False
        perfProps.subdeviceId = 0
        perfProps.engines = p
    def stubzesPerformanceFactorGetConfig(perf):
        global stubState
        p = perf_handle_to_ulong(perf)
        pds = stubState.setdefault("Perf", {})
        return pds.setdefault(p, 50.0)
    def stubzesPerformanceFactorSetConfig(perf, val):
        global stubState
        p = perf_handle_to_ulong(perf)
        pds = stubState.setdefault("Perf", {})
        pds[p] = val
    def stubzesDeviceEnumPsus(dev, count_ptr, handle_array):
        global stubState
        stubState.setdefault("PsuState", ZES_PSU_VOLTAGE_STATUS_NORMAL)
        stubState.setdefault("PsuTable", { ZES_PSU_VOLTAGE_STATUS_UNKNOWN : (True, 250, 100),
                                           ZES_PSU_VOLTAGE_STATUS_NORMAL : (False, 50, 200),
                                           ZES_PSU_VOLTAGE_STATUS_OVER : (True, 150, 750),
                                           ZES_PSU_VOLTAGE_STATUS_UNDER : (False, 75, 150) })
        if handle_array is None:
            uint32_assign(count_ptr, 1)
        elif uint32_value(count_ptr) == 1:
            items = zes_psu_handle_array.frompointer(handle_array)
            items[0] = ulong_to_psu_handle(0)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesPsuGetProperties(psu, psuProps):
        psuProps.onSubdevice = False
        psuProps.subdeviceId = 0
        psuProps.haveFan = True
        psuProps.ampLimit = 750
    def stubzesPsuGetState(psu, psuState):
        global stubState
        voltStatus = stubState["PsuState"]
        psuState.voltStatus = voltStatus
        psuState.fanFailed, psuState.temperature, psuState.current = stubState["PsuTable"][voltStatus]
        stubState["PsuState"] = (voltStatus + 1) % 4
    def stubzesDeviceEnumSchedulers(dev, count_ptr, handle_array):
        global stubState
        DMA_ENGINE_TYPES = ZES_ENGINE_TYPE_FLAG_DMA | ZES_ENGINE_TYPE_FLAG_OTHER
        stubState.setdefault("SchedMode", { ZES_ENGINE_TYPE_FLAG_COMPUTE : ZES_SCHED_MODE_TIMESLICE,
                                            ZES_ENGINE_TYPE_FLAG_3D : ZES_SCHED_MODE_TIMEOUT,
                                            ZES_ENGINE_TYPE_FLAG_MEDIA : ZES_SCHED_MODE_TIMEOUT,
                                            DMA_ENGINE_TYPES : ZES_SCHED_MODE_EXCLUSIVE })
        stubState.setdefault("Timeout", { ZES_ENGINE_TYPE_FLAG_COMPUTE : 5000000,
                                          ZES_ENGINE_TYPE_FLAG_3D : 25000000,
                                          ZES_ENGINE_TYPE_FLAG_MEDIA : 15000000,
                                          DMA_ENGINE_TYPES : 1000000 })
        stubState.setdefault("Timeslice", { ZES_ENGINE_TYPE_FLAG_COMPUTE : (500000, 5000000),
                                            ZES_ENGINE_TYPE_FLAG_3D : (1000000, 25000000),
                                            ZES_ENGINE_TYPE_FLAG_MEDIA : (750000, 15000000),
                                            DMA_ENGINE_TYPES : (500000, 1000000) })
        if handle_array is None:
            uint32_assign(count_ptr, 4)
        elif uint32_value(count_ptr) == 4:
            items = zes_sched_handle_array.frompointer(handle_array)
            items[0] = ulong_to_sched_handle(ZES_ENGINE_TYPE_FLAG_COMPUTE)
            items[1] = ulong_to_sched_handle(ZES_ENGINE_TYPE_FLAG_3D)
            items[2] = ulong_to_sched_handle(ZES_ENGINE_TYPE_FLAG_MEDIA)
            items[3] = ulong_to_sched_handle(DMA_ENGINE_TYPES)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesSchedulerGetProperties(sched, schedProps):
        s = sched_handle_to_ulong(sched)
        schedProps.onSubdevice = False
        schedProps.subdeviceId = 0
        schedProps.canControl = not (s & ZES_ENGINE_TYPE_FLAG_DMA)
        schedProps.engines = s
        supportedModes = 0
        if s & ZES_ENGINE_TYPE_FLAG_DMA:
            supportedModes = 1 << ZES_SCHED_MODE_EXCLUSIVE
        if s & ZES_ENGINE_TYPE_FLAG_COMPUTE:
            supportedModes |= 1 << ZES_SCHED_MODE_TIMEOUT
            supportedModes |= 1 << ZES_SCHED_MODE_TIMESLICE
            supportedModes |= 1 << ZES_SCHED_MODE_EXCLUSIVE
            supportedModes |= 1 << ZES_SCHED_MODE_COMPUTE_UNIT_DEBUG
        if s & ZES_ENGINE_TYPE_FLAG_3D:
            supportedModes |= 1 << ZES_SCHED_MODE_TIMESLICE
        if s & ZES_ENGINE_TYPE_FLAG_MEDIA:
            supportedModes |= 1 << ZES_SCHED_MODE_TIMEOUT
            supportedModes |= 1 << ZES_SCHED_MODE_EXCLUSIVE
        schedProps.supportedModes = supportedModes
    def stubzesSchedulerGetCurrentMode(sched):
        global stubState
        s = sched_handle_to_ulong(sched)
        return stubState["SchedMode"][s]
    def stubzesSchedulerGetTimeoutModeProperties(sched, getDefaults, schedConfig):
        global stubState
        s = sched_handle_to_ulong(sched)
        DMA_ENGINE_TYPES = ZES_ENGINE_TYPE_FLAG_DMA | ZES_ENGINE_TYPE_FLAG_OTHER
        if getDefaults:
            timeoutProperties = { ZES_ENGINE_TYPE_FLAG_COMPUTE : 5000000,
                                  ZES_ENGINE_TYPE_FLAG_3D : 25000000,
                                  ZES_ENGINE_TYPE_FLAG_MEDIA : 15000000,
                                  DMA_ENGINE_TYPES : 1000000 }
        else:
            timeoutProperties = stubState["Timeout"]
        schedConfig.watchdogTimeout = timeoutProperties[s]
    def stubzesSchedulerGetTimesliceModeProperties(sched, getDefaults, schedConfig):
        global stubState
        s = sched_handle_to_ulong(sched)
        DMA_ENGINE_TYPES = ZES_ENGINE_TYPE_FLAG_DMA | ZES_ENGINE_TYPE_FLAG_OTHER
        if getDefaults:
            timesliceProperties = { ZES_ENGINE_TYPE_FLAG_COMPUTE : (500000, 5000000),
                                    ZES_ENGINE_TYPE_FLAG_3D : (1000000, 25000000),
                                    ZES_ENGINE_TYPE_FLAG_MEDIA : (750000, 15000000),
                                    DMA_ENGINE_TYPES : (500000, 1000000) }
        else:
            timesliceProperties = stubState["Timeslice"]
        schedConfig.interval, schedConfig.yieldTimeout = timesliceProperties[s]
    def stubzesSchedulerSetTimeoutMode(sched, schedConfig):
        global stubState
        s = sched_handle_to_ulong(sched)
        needReload = stubState["SchedMode"][s] != ZES_SCHED_MODE_TIMEOUT
        stubState["SchedMode"][s] = ZES_SCHED_MODE_TIMEOUT
        if schedConfig:
            stubState["Timeout"][s] = schedConfig.watchdogTimeout
        return needReload
    def stubzesSchedulerSetTimesliceMode(sched, schedConfig):
        global stubState
        s = sched_handle_to_ulong(sched)
        needReload = stubState["SchedMode"][s] != ZES_SCHED_MODE_TIMESLICE
        stubState["SchedMode"][s] = ZES_SCHED_MODE_TIMESLICE
        if schedConfig:
            stubState["Timeslice"][s] = schedConfig.interval, schedConfig.yieldTimeout
        return needReload
    def stubzesSchedulerSetExclusiveMode(sched):
        global stubState
        s = sched_handle_to_ulong(sched)
        needReload = stubState["SchedMode"][s] != ZES_SCHED_MODE_EXCLUSIVE
        stubState["SchedMode"][s] = ZES_SCHED_MODE_EXCLUSIVE
        return needReload
    def stubzesSchedulerSetComputeUnitDebugMode(sched):
        global stubState
        s = sched_handle_to_ulong(sched)
        needReload = stubState["SchedMode"][s] != ZES_SCHED_MODE_COMPUTE_UNIT_DEBUG
        stubState["SchedMode"][s] = ZES_SCHED_MODE_COMPUTE_UNIT_DEBUG
        return needReload
    def stubzesDeviceEnumStandbyDomains(dev, count_ptr, handle_array):
        if handle_array is None:
            uint32_assign(count_ptr, 1)
        elif uint32_value(count_ptr) == 1:
            items = zes_standby_handle_array.frompointer(handle_array)
            items[0] = ulong_to_standby_handle(0)
        else:
            raise ValueError(uint32_value(count_ptr))
    def stubzesStandbyGetProperties(stby, stbyProps):
        stbyProps.type = ZES_STANDBY_TYPE_GLOBAL
        stbyProps.onSubdevice = False
        stbyProps.subdeviceId = 0
    def stubzesStandbyGetMode(stby):
        global stubState
        return stubState.setdefault("Standby", ZES_STANDBY_PROMO_MODE_DEFAULT)
    def stubzesStandbySetMode(stby, stbyMode):
        global stubState
        stubState["Standby"] = stbyMode

    def isStub(fn):
        return fn.startswith("stubze") and eval("type(%s) == type(isStub)" % fn)

    fntemplate = "def %s(*args, **kwargs):\n    return {'fn':%s, 'args':args, 'kwargs':kwargs}\n"

    for f in filter(isStub, dir()):
        exec(fntemplate % (f[4:], f))

# Call ZE function, stripping (first) return code and converting non-success to exception:
def zeCall(rc):
    if type(rc) == type({}):
        return rc['fn'](*rc['args'], **rc['kwargs'])
    elif type(rc) in (type(()),type([])):
        val = rc[1:]
        rc = rc[0]
        if len(val) == 1:
            val = val[0]
    else:
        val = None
    if rc == ZE_RESULT_ERROR_UNSUPPORTED_FEATURE:
        raise NotImplementedError
    elif rc != ZE_RESULT_SUCCESS:
        raise ValueError(resultString(rc))
    return val

#
# ZE string conversions
#

def fmtknown(value, fmt="%.1f", unknown="?"):
    if value < 0:
        return unknown
    else:
        return value

def knownvalue(value, unknown="?"):
    if value < 0:
        return unknown
    else:
        return value

def ipcPropertiesString(ipcProps):
    if not ipcProps:
        return "None"

    ipcProperties = [(ZE_IPC_PROPERTY_FLAG_MEMORY, "Memory allocations"),
                     (ZE_IPC_PROPERTY_FLAG_EVENT_POOL, "Events")]

    propStrings = []
    for p, s in ipcProperties:
        if ipcProps & p:
            ipcProps ^= p
            propStrings.append(s)
    if ipcProps != 0:
        propStrings.append("Unknown property")

    return ", ".join(propStrings)

def versionString(version):
    return str(version >> 16) + "." + str(version & 0xffff)

def deviceTypeString(devType):
    devTypes = { ZE_DEVICE_TYPE_GPU : "GPU",
                 ZE_DEVICE_TYPE_FPGA : "FPGA" }
    return devTypes.get(devType, "Unknown")

def resetReasonsString(reasons):
    if not reasons:
        return "Not required"

    resetReasons = [(ZES_RESET_REASON_FLAG_WEDGED, "Hardware is wedged"),
                    (ZES_RESET_REASON_FLAG_REPAIR, "Required for in-field repairs")]
    reasonStrings = []
    for r, s in reasonReasons:
        if reasons & r:
            reasons ^= r
            reasonStrings.append(s)
    if reasons != 0:
        reasonStrings.append("Unknown reset reason")

    return ", ".join(reasonStrings)

def repairStatusString(repairStatus):
    repairStatuses = { ZES_REPAIR_STATUS_UNSUPPORTED : "Unsupported",
                       ZES_REPAIR_STATUS_NOT_PERFORMED : "Unrepaired",
                       ZES_REPAIR_STATUS_PERFORMED : "Repaired" }
    return repairStatuses.get(repairStatus, "Unknown")

def tempTypeString(tempType):
    tempTypes = { ZES_TEMP_SENSORS_GLOBAL : "Overall",
                  ZES_TEMP_SENSORS_GPU : "GPU",
                  ZES_TEMP_SENSORS_MEMORY : "Memory",
                  ZES_TEMP_SENSORS_GLOBAL_MIN : "Overall_Min",
                  ZES_TEMP_SENSORS_GPU_MIN : "GPU_Min",
                  ZES_TEMP_SENSORS_MEMORY_MIN : "Memory_Min" }
    return tempTypes.get(tempType, "Unknown")

def freqTypeString(freqType):
    freqTypes = { ZES_FREQ_DOMAIN_GPU : "GPU",
                  ZES_FREQ_DOMAIN_MEMORY : "Memory" }
    return freqTypes.get(freqType, "Unknown")

def ocModeString(mode):
    ocModes = { ZES_OC_MODE_OFF : "Off",
                ZES_OC_MODE_OVERRIDE : "Override",
                ZES_OC_MODE_INTERPOLATIVE : "Interpolative",
                ZES_OC_MODE_FIXED : "Fixed" }
    return ocModes.get(mode, "Unknown")

def engTypeString(engType):
    engTypes = { ZES_ENGINE_GROUP_ALL : "AllEngines",
                 ZES_ENGINE_GROUP_COMPUTE_ALL : "AllComputeEngines",
                 ZES_ENGINE_GROUP_MEDIA_ALL : "AllMediaEngines",
                 ZES_ENGINE_GROUP_COPY_ALL : "AllCopyEngines",
                 ZES_ENGINE_GROUP_COMPUTE_SINGLE : "ComputeEngine",
                 ZES_ENGINE_GROUP_RENDER_SINGLE : "RenderEngine",
                 ZES_ENGINE_GROUP_MEDIA_DECODE_SINGLE : "MediaDecodeEngine",
                 ZES_ENGINE_GROUP_MEDIA_ENCODE_SINGLE : "MediaEncodeEngine",
                 ZES_ENGINE_GROUP_COPY_SINGLE : "CopyEngine" }
    return engTypes.get(engType, "Unknown")

def memTypeString(memType):
    memTypes = { ZES_MEM_TYPE_HBM : "HBM",
                 ZES_MEM_TYPE_DDR : "DDR",
                 ZES_MEM_TYPE_DDR3 : "DDR3",
                 ZES_MEM_TYPE_DDR4 : "DDR4",
                 ZES_MEM_TYPE_DDR5 : "DDR5",
                 ZES_MEM_TYPE_LPDDR : "LPDDR",
                 ZES_MEM_TYPE_LPDDR3 : "LPDDR3",
                 ZES_MEM_TYPE_LPDDR4 : "LPDDR4",
                 ZES_MEM_TYPE_LPDDR5 : "LPDDR5",
                 ZES_MEM_TYPE_SRAM : "SRAM",
                 ZES_MEM_TYPE_L1 : "L1",
                 ZES_MEM_TYPE_L3 : "L3",
                 ZES_MEM_TYPE_GRF : "GRF",
                 ZES_MEM_TYPE_SLM : "SLM" }
    return memTypes.get(memType, "Unknown")

def memLocString(memLoc):
    memLocs = { ZES_MEM_LOC_SYSTEM : "System",
                ZES_MEM_LOC_DEVICE : "Device" }
    return memLocs.get(memLoc, "Unknown")

def barTypeString(barType):
    barTypes = { ZES_PCI_BAR_TYPE_MMIO : "MMIO",
                 ZES_PCI_BAR_TYPE_ROM : "ROM",
                 ZES_PCI_BAR_TYPE_MEM : "MEM" }
    return barTypes.get(barType, "Unknown")

def memHealthString(memHealth):
    memHealths = { ZES_MEM_HEALTH_OK : "Good",
                   ZES_MEM_HEALTH_DEGRADED : "Degraded",
                   ZES_MEM_HEALTH_CRITICAL : "Critical",
                   ZES_MEM_HEALTH_REPLACE : "Replace" }
    return memHealths.get(memHealth, "Unknown")

def throttleReasonsString(reasons):
    if not reasons:
        return "Not throttled"

    throttleReasons = [(ZES_FREQ_THROTTLE_REASON_FLAG_AVE_PWR_CAP, "Exceeded sustained power limit"),
                       (ZES_FREQ_THROTTLE_REASON_FLAG_BURST_PWR_CAP, "Exceeded burst power limit"),
                       (ZES_FREQ_THROTTLE_REASON_FLAG_CURRENT_LIMIT, "Exceeded electrical limits"),
                       (ZES_FREQ_THROTTLE_REASON_FLAG_THERMAL_LIMIT, "Exceeded temperature limit"),
                       (ZES_FREQ_THROTTLE_REASON_FLAG_PSU_ALERT, "Exceeded power supply limits"),
                       (ZES_FREQ_THROTTLE_REASON_FLAG_SW_RANGE, "Request outside software limits"),
                       (ZES_FREQ_THROTTLE_REASON_FLAG_HW_RANGE, "Request outside hardware limits")]
    reasonStrings = []
    for r, s in throttleReasons:
        if reasons & r:
            reasons ^= r
            reasonStrings.append(s)
    if reasons != 0:
        reasonStrings.append("Unknown throttle reason")

    return ", ".join(reasonStrings)

def pciLinkStatusString(pciLinkStatus):
    pciLinkStatuses = { ZES_PCI_LINK_STATUS_GOOD : "Good",
                        ZES_PCI_LINK_STATUS_UNKNOWN : "Unknown",
                        ZES_PCI_LINK_STATUS_QUALITY_ISSUES : "Degraded",
                        ZES_PCI_LINK_STATUS_STABILITY_ISSUES : "Unstable" }
    return pciLinkStatuses.get(pciLinkStatus, "Unknown")

def pciQualityIssuesString(reasons):
    if not reasons:
        return "None"

    qualityIssues = [(ZES_PCI_LINK_QUAL_ISSUE_FLAG_REPLAYS, "Excessive packet replays"),
                     (ZES_PCI_LINK_QUAL_ISSUE_FLAG_SPEED, "Reduced bitrate")]
    reasonStrings = []
    for r, s in qualityIssues:
        if reasons & r:
            reasons ^= r
            reasonStrings.append(s)
    if reasons != 0:
        reasonStrings.append("Unknown degradation reason")

    return ", ".join(reasonStrings)

def pciStabilityIssuesString(reasons):
    if not reasons:
        return "None"

    stabilityIssues = [(ZES_PCI_LINK_STAB_ISSUE_FLAG_RETRAINING, "Link retraining occurred")]
    reasonStrings = []
    for r, s in stabilityIssues:
        if reasons & r:
            reasons ^= r
            reasonStrings.append(s)
    if reasons != 0:
        reasonStrings.append("Unknown stability issue")

    return ", ".join(reasonStrings)

def portStatusString(portStatus):
    portStatuses = { ZES_FABRIC_PORT_STATUS_UNKNOWN : "Unknown",
                     ZES_FABRIC_PORT_STATUS_HEALTHY : "Good",
                     ZES_FABRIC_PORT_STATUS_DEGRADED : "Degraded",
                     ZES_FABRIC_PORT_STATUS_FAILED : "Failed",
                     ZES_FABRIC_PORT_STATUS_DISABLED : "Off" }
    return portStatuses.get(portStatus, "Unknown")

def portQualityIssuesString(reasons):
    if not reasons:
        return "None"

    qualityIssues = [(ZES_FABRIC_PORT_QUAL_ISSUE_FLAG_LINK_ERRORS, "Excessive link errors"),
                     (ZES_FABRIC_PORT_QUAL_ISSUE_FLAG_SPEED, "Reduced bitrate/width")]
    reasonStrings = []
    for r, s in qualityIssues:
        if reasons & r:
            reasons ^= r
            reasonStrings.append(s)
    if reasons != 0:
        reasonStrings.append("Unknown degradation reason")

    return ", ".join(reasonStrings)

def portFailureReasonsString(reasons):
    if not reasons:
        return "None"

    failureReasons = [(ZES_FABRIC_PORT_FAILURE_FLAG_FAILED, "Port failure"),
                      (ZES_FABRIC_PORT_FAILURE_FLAG_TRAINING_TIMEOUT, "Training timeout"),
                      (ZES_FABRIC_PORT_FAILURE_FLAG_FLAPPING, "Flapping")]
    reasonStrings = []
    for r, s in failureReasons:
        if reasons & r:
            reasons ^= r
            reasonStrings.append(s)
    if reasons != 0:
        reasonStrings.append("Unknown failure")

    return ", ".join(reasonStrings)

def rasTypeString(rasType):
    rasTypes = { ZES_RAS_ERROR_TYPE_CORRECTABLE : "Correctable",
                 ZES_RAS_ERROR_TYPE_UNCORRECTABLE : "Uncorrectable" }
    return rasTypes.get(rasType, "Unknown")

def stbyTypeString(stbyType):
    stbyTypes = { ZES_STANDBY_TYPE_GLOBAL : "Global" }
    return stbyTypes.get(stbyType, "Unknown")

def stbyPromoModeString(stbyPromoMode):
    stbyPromoModes = { ZES_STANDBY_PROMO_MODE_DEFAULT : "Enabled",
                       ZES_STANDBY_PROMO_MODE_NEVER : "Disabled" }
    return stbyPromoModes.get(stbyPromoMode, "Unknown")

def enginesUsedString(engines):
    if not engines:
        return "None"

    engineTypes = [(1 << ZES_ENGINE_TYPE_FLAG_OTHER, "Other"),
                   (1 << ZES_ENGINE_TYPE_FLAG_COMPUTE, "Compute"),
                   (1 << ZES_ENGINE_TYPE_FLAG_3D, "3D"),
                   (1 << ZES_ENGINE_TYPE_FLAG_MEDIA, "Media"),
                   (1 << ZES_ENGINE_TYPE_FLAG_DMA, "DMA")]

    engineStrings = []
    for t, s in engineTypes:
        if engines & t:
            engines ^= t
            engineStrings.append(s)

    if engines != 0:
        engineStrings.append("Unknown engine")

    return ", ".join(engineStrings)

def schedModeString(schedMode):
    schedModes = { ZES_SCHED_MODE_TIMEOUT : "Timeout",
                   ZES_SCHED_MODE_TIMESLICE : "Timeslice",
                   ZES_SCHED_MODE_EXCLUSIVE : "Exclusive",
                   ZES_SCHED_MODE_COMPUTE_UNIT_DEBUG : "Debug" }
    return schedModes.get(schedMode, "Unknown")

def schedSupportedModesString(schedMode):
    schedModes = [ZES_SCHED_MODE_TIMEOUT, ZES_SCHED_MODE_TIMESLICE, ZES_SCHED_MODE_EXCLUSIVE,
                  ZES_SCHED_MODE_COMPUTE_UNIT_DEBUG]

    modesStrings = []
    for m in schedModes:
        if schedMode & (1 << m):
            schedMode ^= (1 << m)
            modesStrings.append(schedModeString(m))

    if schedMode != 0:
        modesStrings.append("Unknown mode")

    return ", ".join(modesStrings)

def diagResultString(diagResult):
    diagResults = { ZES_DIAG_RESULT_NO_ERRORS : "Pass",
                    ZES_DIAG_RESULT_ABORT : "Diagnostic aborted",
                    ZES_DIAG_RESULT_FAIL_CANT_REPAIR : "Fail, irreparable",
                    ZES_DIAG_RESULT_REBOOT_FOR_REPAIR : "Fail, reboot required" }
    return diagResults.get(diagResult, "Unknown")

def eventsString(events):
    if not events:
        return "None"

    eventCodes = [ (ZES_EVENT_TYPE_FLAG_DEVICE_DETACH, "Detach"),
                   (ZES_EVENT_TYPE_FLAG_DEVICE_ATTACH, "Reattach"),
                   (ZES_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_ENTER, "Sleeping"),
                   (ZES_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_EXIT, "Waking"),
                   (ZES_EVENT_TYPE_FLAG_FREQ_THROTTLED, "Frequency throttled"),
                   (ZES_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED, "Energy threshold"),
                   (ZES_EVENT_TYPE_FLAG_TEMP_CRITICAL, "Temperature critical"),
                   (ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD1, "Temperature threshold 1"),
                   (ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD2, "Temperature threshold 2"),
                   (ZES_EVENT_TYPE_FLAG_MEM_HEALTH, "Memory health change"),
                   (ZES_EVENT_TYPE_FLAG_FABRIC_PORT_HEALTH, "Port health change"),
                   (ZES_EVENT_TYPE_FLAG_PCI_LINK_HEALTH, "PCI health change"),
                   (ZES_EVENT_TYPE_FLAG_RAS_CORRECTABLE_ERRORS, "Correctable error threshold"),
                   (ZES_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS, "Uncorrectable error threshold"),
                   (ZES_EVENT_TYPE_FLAG_DEVICE_RESET_REQUIRED, "Reset required") ]

    eventStrings = []
    for t, s in eventCodes:
        if events & t:
            events ^= t
            eventStrings.append(s)

    if events != 0:
        eventStrings.append("Unknown event")

    return ", ".join(eventStrings)

def fanModeString(mode):
    fanModes = { ZES_FAN_SPEED_MODE_DEFAULT:  "Default",
                 ZES_FAN_SPEED_MODE_FIXED : "Fixed",
                 ZES_FAN_SPEED_MODE_TABLE : "Table" }
    return fanModes.get(mode, "Unknown")

def supportedFanModesString(modes):
    if not modes:
        return "None"

    allModes = [ ZES_FAN_SPEED_MODE_DEFAULT, ZES_FAN_SPEED_MODE_FIXED, ZES_FAN_SPEED_MODE_TABLE ]

    modeStrings = []
    for m in allModes:
        if modes & (1 << m):
            modes ^= (1 << m)
            modeStrings.append(fanModeString(m))

    if modes != 0:
        modeStrings.append("Unknown")

    return ", ".join(modeStrings)

def fanUnitString(unit):
    fanUnits = { ZES_FAN_SPEED_UNITS_RPM : "RPM",
                 ZES_FAN_SPEED_UNITS_PERCENT : "%" }
    return fanUnits.get(unit, "Unknown")

def supportedFanUnitsString(units):
    if not units:
        return "None"

    allUnits = [ ZES_FAN_SPEED_UNITS_RPM, ZES_FAN_SPEED_UNITS_PERCENT ]

    unitStrings = []
    for u in allUnits:
        if units & (1 << u):
            units ^= (1 << u)
            unitStrings.append(fanUnitString(u))

    if units != 0:
        unitStrings.append("Unknown")

    return ", ".join(unitStrings)

def psuVoltageStatusString(status):
    psuVoltageStatuses = { ZES_PSU_VOLTAGE_STATUS_NORMAL : "Normal",
                           ZES_PSU_VOLTAGE_STATUS_OVER : "Overvoltage",
                           ZES_PSU_VOLTAGE_STATUS_UNDER : "Undervoltage" }
    return psuVoltageStatuses.get(status, "Unknown")

def c6(fraction):
    colorTable = (0, 11, 16, 21, 26, 31)
    refVal = fraction * 32
    return min(range(6), key=lambda x:abs(colorTable[x] - refVal))

def colorCodeAnsi256(red, green, blue):
    return 16 + 36 * c6(red) + 6 * c6(green) + c6(blue)

def colorBlockAnsi256(color):
    return "\x1b[0m[\x1b[48;5;%dm \x1b[0m]" % color

def onOffString(on):
    if on:
        return "On"
    else:
        return "Off"

addAnsi256ColorBlock = False

def colorString(colors):
    s = "%.2f / %.2f / %.2f" % (colors.red, colors.green, colors.blue)
    if addAnsi256ColorBlock:
        s += " " + colorBlockAnsi256(colorCodeAnsi256(colors.red, colors.green, colors.blue))
    return s

def fullUUID(uuid):
    return uuid

def tinyUUID(uuid):
    return uuid[:2] + ".." + uuid[-2:]

deviceUUID = fullUUID

# Helper for indexing lists
# To allow *args to be empty, change to: return args and zip(range(len(args[0])), *args)
def indexed(*args):
    return zip(range(len(args[0])), *args)

def driverUUIDs(count, drivers):
    uuids = []
    for i in range(count):
        driver = drivers[i]
        driver_props = ze_typed_structure(ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES)
        zeCall(zeDriverGetProperties(driver, driver_props))
        uuid_string = uuid_string_t()
        driver_uuid_to_string(driver_props.uuid, uuid_string)
        uuids.append(str(uuid_string.id))
    return uuids

def listDrivers(count, drivers):
    pr.err("Available drivers:")
    for i in range(count):
        pr.err("Driver", i, ":")
        driver = drivers[i]
        api_version = zeCall(zeDriverGetApiVersion(driver))
        pr.err("  API version:", versionString(api_version))
        driver_props = ze_typed_structure(ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES)
        zeCall(zeDriverGetProperties(driver, driver_props))
        uuid_string = uuid_string_t()
        driver_uuid_to_string(driver_props.uuid, uuid_string)
        pr.err("  uuid:", uuid_string.id)
        pr.err("  driver version:", driver_props.driverVersion)
        ipcProps = ze_typed_structure(ZE_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES)
        zeCall(zeDriverGetIpcProperties(driver, ipcProps))
        pr.err("  IPC passing:", ipcPropertiesString(ipcProps.flags))

def listDriversAndFail(count, drivers):
    listDrivers(count, drivers)
    pr.fail("Use --driver to specify a valid driver")

def listDevices(driverIndices, deviceCounts, deviceLists):
    pr.err("Available devices:")
    for driver, count, devices in zip(driverIndices, deviceCounts, deviceLists):
        for i in range(count):
            if len(driverIndices) > 1:
                pr.err("Device", str(driver) + "." + str(i), ":")
            else:
                pr.err("Device", i, ":")
            device = devices[i]
            device_properties = ze_typed_structure(ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES)
            zeCall(zeDeviceGetProperties(device, device_properties))
            devType = deviceTypeString(device_properties.type)
            pr.err("  type:", devType)
            pr.err("  name:", device_properties.name)
            pr.err("  vendorId:", hex(device_properties.vendorId))
            pr.err("  deviceId:", hex(device_properties.deviceId))
            uuid_string = uuid_string_t()
            device_uuid_to_string(device_properties.uuid, uuid_string)
            pr.err("  uuid:", uuid_string.id)

def listDevicesAndFail(driverIndices, deviceCounts, deviceLists):
    listDevices(driverIndices, deviceCounts, deviceLists)
    pr.fail("Use --device to specify a set of valid devices")

def getDrivers(driverSelection):
    driverCount = uint32_ptr()
    zeCall(zeDriverGet(driverCount.cast(), None))
    numDrivers = driverCount.value()
    if numDrivers < 1:
        pr.fail("No compatible drivers found")

    drivers = ze_driver_handle_array(numDrivers)
    zeCall(zeDriverGet(driverCount.cast(), drivers.cast()))

    if driverSelection:
        indices = []
        uuids = driverUUIDs(numDrivers, drivers)
        for sel in driverSelection:
            sel = sel.lower()

            if sel == "list":
                listDrivers(numDrivers, drivers)
                exit(0)

            if sel in uuids:
                i = uuids.index(sel)
            else:
                try:
                    i = int(sel, 0)
                    if i < 0 or i >= numDrivers:
                        raise
                except:
                    pr.err("Error: Illegal driver index/UUID", sel, "specified")
                    listDriversAndFail(numDrivers, drivers)
            indices.append(i)

        # uniquify:
        indices = list(set(indices))
        indices.sort()
    else:
        indices = range(numDrivers)

    return indices, drivers

def getDeviceUUIDs(deviceCounts, deviceLists):
    uuids = []
    for count, devices in zip(deviceCounts, deviceLists):
        for i in range(count):
            device = devices[i]
            device_properties = ze_typed_structure(ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES)
            zeCall(zeDeviceGetProperties(device, device_properties))
            uuid_string = uuid_string_t()
            device_uuid_to_string(device_properties.uuid, uuid_string)
            uuids.append(str(uuid_string.id))
    return uuids

def listDevices(driverIndices, deviceCounts, deviceLists):
    pr.err("Available devices:")
    for driver, count, devices in zip(driverIndices, deviceCounts, deviceLists):
        for i in range(count):
            if len(driverIndices) > 1:
                pr.err("Device", str(driver) + "." + str(i), ":")
            else:
                pr.err("Device", i, ":")
            device = devices[i]
            device_properties = ze_typed_structure(ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES)
            zeCall(zeDeviceGetProperties(device, device_properties))
            devType = deviceTypeString(device_properties.type)
            pr.err("  type:", devType)
            pr.err("  name:", device_properties.name)
            pr.err("  vendorId:", hex(device_properties.vendorId))
            pr.err("  deviceId:", hex(device_properties.deviceId))
            uuid_string = uuid_string_t()
            device_uuid_to_string(device_properties.uuid, uuid_string)
            pr.err("  uuid:", uuid_string.id)

def firstMatch(sel, *places):
    for place in places:
        if sel in place:
            return place.index(sel)
    return None

def getDevices(driverIndices, drivers, deviceSelection):
    deviceFound = False
    deviceCounts = []
    deviceLists = []

    for _,driver in zip(driverIndices, drivers):
        deviceCount = uint32_ptr()
        zeCall(zeDeviceGet(driver, deviceCount.cast(), None))

        if deviceCount.value() > 0:
            deviceFound = True
            driverDevices = ze_device_handle_array(deviceCount.value())
            zeCall(zeDeviceGet(driver, deviceCount.cast(), driverDevices.cast()))
        else:
            driverDevices = None

        deviceCounts.append(deviceCount.value())
        deviceLists.append(driverDevices)

    if not deviceFound:
        pr.fail("No devices found")

    allUUIDs = getDeviceUUIDs(deviceCounts, deviceLists)
    allIndices = [ (r,d) for r,c in indexed(deviceCounts) for d in range(c) ]

    expandedIDs = [ str(driverIndices[r]) + "." + str(d) for r,d in allIndices ]

    if len(driverIndices) > 1:
        deviceIDs = expandedIDs
    else:
        deviceIDs = [ str(d) for r, d in allIndices ]

    if deviceSelection:
        indices = []
        deviceUUIDs = []
        for sel in deviceSelection:
            sel = sel.lower()

            if sel == "list":
                listDevices(driverIndices, deviceCounts, deviceLists)
                exit(0)

            i = firstMatch(sel, allUUIDs, deviceIDs, expandedIDs)

            if i is None:
                pr.err("Error: Illegal device index/UUID", sel, "specified")
                listDevicesAndFail(driverIndices, deviceCounts, deviceLists)
            else:
                indices.append(allIndices[i])
                deviceUUIDs.append(allUUIDs[i])

        if len(driverIndices) > 1:
            deviceIDs = [ str(driverIndices[r]) + "." + str(d) for r, d in indices ]
        else:
            deviceIDs = [ str(d) for r, d in indices ]
    else:
        indices = allIndices
        deviceUUIDs = allUUIDs

    sysmanDevices = [deviceLists[r][d] for r,d in indices]

    return deviceIDs, deviceUUIDs, sysmanDevices

#
# Parse arguments
#
def parseArgs():
    global ZESYSMAN_PROG_VERSION
    global formatArgClass, formatExtClass, Node
    global pr
    global indentStr
    global deviceUUID, maxIterations
    global condensedList
    global IndexAttributes, SecondaryIndexAttributes
    global replaceUnimplementedFunctions
    global addAnsi256ColorBlock

    helpFormatter=lambda prog: argparse.HelpFormatter(prog, max_help_position=48)

    parser = argparse.ArgumentParser(description="Access SYSMAN services",
                                     formatter_class=helpFormatter)

    parser.add_argument("-v","--version", action='version', version="%(prog)s " + ZESYSMAN_PROG_VERSION,
                        help="report version information")
    parser.add_argument("--driver", metavar='DRV', nargs='+', help="specify driver (index/UUID)")
    parser.add_argument("-d", "--device", metavar='D', nargs='+', help="specify device (index/UUID)")
    parser.add_argument("-i", "--show-inventory", action='store_true', help="show inventory data")
    parser.add_argument("-l", "--show-telemetry", action='store_true', help="show telemetry data")
    parser.add_argument("-t", "--show-temp", action='store_true', help="show temperature")
    parser.add_argument("-p", "--show-power", action='store_true', help="show power")
    parser.add_argument("-c", "--show-freq", "--show-clocks", action='store_true', help="show frequency")
    parser.add_argument("-u", "--show-util", action='store_true', help="show utilization")
    parser.add_argument("-m", "--show-mem", action='store_true', help="show memory stats")
    parser.add_argument("-x", "--show-pci", action='store_true', help="show PCI bandwidth")
    parser.add_argument("--show-fabric-ports", action='store_true', help="show fabric ports")
    parser.add_argument("-b", "--show-standby", action='store_true', help="show standby promotion")
    parser.add_argument("-e", "--show-errors", action='store_true', help="show errors")
    parser.add_argument("-a", "--show-all", action='store_true', help="show all sysman attributes")
    parser.add_argument("--show-device", action='store_true', help="show device attributes")
    parser.add_argument("--show-processes", action='store_true', help="show process usage")
    parser.add_argument("--show-scheduler", action='store_true', help="show scheduler mode")
    parser.add_argument("--show-diag", action='store_true', help="show diagnostic test suites")
    parser.add_argument("--verbose", action='store_true', help="show extra attributes")
    parser.add_argument("--poll", metavar='TIME', type=int,
                        help="set sampling interval (in s by default)")
    parser.add_argument("--iterations", metavar='NUM', type=int,
                        help="samples to collect (0 = until stopped)")
    parser.add_argument("--enable-critical-temp", nargs=1, metavar='IDX', type=int,
                        help="enable critical temperature sensor")
    parser.add_argument("--disable-critical-temp", nargs=1, metavar='IDX', type=int,
                        help="disable critical temperature sensor")
    parser.add_argument("--enable-t1-low-to-high", nargs=1, metavar='IDX', type=int,
                        help="enable low-to-high temperature threshold 1")
    parser.add_argument("--disable-t1-low-to-high", nargs=1, metavar='IDX', type=int,
                        help="disable low-to-high temperature threshold 1")
    parser.add_argument("--enable-t1-high-to-low", nargs=1, metavar='IDX', type=int,
                        help="enable high-to-low temperature threshold 1")
    parser.add_argument("--disable-t1-high-to-low", nargs=1, metavar='IDX', type=int,
                        help="disable high-to-low temperature threshold 1")
    parser.add_argument("--set-t1-threshold", nargs=2, metavar=('IDX','C'), type=int,
                        help="set temperature threshold 1")
    parser.add_argument("--enable-t2-low-to-high", nargs=1, metavar='IDX', type=int,
                        help="enable low-to-high temperature threshold 2")
    parser.add_argument("--disable-t2-low-to-high", nargs=1, metavar='IDX', type=int,
                        help="disable low-to-high temperature threshold 2")
    parser.add_argument("--enable-t2-high-to-low", nargs=1, metavar='IDX', type=int,
                        help="enable high-to-low temperature threshold 2")
    parser.add_argument("--disable-t2-high-to-low", nargs=1, metavar='IDX', type=int,
                        help="disable high-to-low temperature threshold 2")
    parser.add_argument("--set-t2-threshold", nargs=2, metavar=('IDX','C'), type=int,
                        help="set temperature threshold 2")
    parser.add_argument("--set-power", nargs='+', metavar=('POW','TAU'),
                        help="set sustained power limit")
    parser.add_argument("--set-burst-power", nargs='+', metavar=('POW',''),
                        help="set burst power limit")
    parser.add_argument("--set-peak-power", nargs='+', metavar=('POW',''),
                        help="set peak power limit")
    parser.add_argument("--set-energy-threshold", nargs='+', metavar=('J',''),
                        help="set energy threshold")
    parser.add_argument("--set-freq", nargs='+', metavar=('MIN','MAX'), help="set frequency limits")
    parser.add_argument("--set-scheduler", nargs='+', metavar=('IDX','MODE'), help="set scheduler mode")
    parser.add_argument("--clear-errors", action='store_true', help="clear error counters")
    parser.add_argument("--set-error-thresholds", nargs='+', type=int, metavar=('TYPE','N'),
                        help="set error thresholds")
    parser.add_argument("--enable-fabric-ports", nargs='*', type=int, metavar='IDX',
                        help="enable fabric ports")
    parser.add_argument("--disable-fabric-ports", nargs='*', type=int, metavar='IDX',
                        help="disable fabric ports")
    parser.add_argument("--enable-beaconing", nargs='*', type=int, metavar='IDX',
                        help="enable port beaconing")
    parser.add_argument("--disable-beaconing", nargs='*', type=int, metavar='IDX',
                        help="disable port beaconing")
    parser.add_argument("--set-standby", metavar='MODE', help="set sleep state promotion mode")
    parser.add_argument("--reset", action='store_true', help="reset specified device")
    parser.add_argument("--force", action='store_true', help="forcibly kill processes on reset")
    parser.add_argument("-y", "--yes", action='store_true', help="do not ask for reset confirmation")
    parser.add_argument("--run-diag", nargs='+', metavar=('SUITE','N'),
                        help="run diagnostic test suites")
    parser.add_argument("-f", "--format", metavar='FMT', choices=["list","xml","table","csv"],
                        help="specify output format (list/xml/table/csv)")
    parser.add_argument("--output", metavar='FILE', help="output to FILE")
    parser.add_argument("--tee", action='store_true', help="print to standard output also")
    parser.add_argument("--indent", metavar='COUNT', type=int,
                        help="use COUNT space (or -COUNT tab) indents")
    parser.add_argument("--style", choices=["condensed","aligned"], help="change output style")
    parser.add_argument("--uuid-index", action='store_true', help="use UUID as index")
    parser.add_argument("--ascii", action='store_true', help="use only 7-bit ascii characters")
    # Only support development features and in-development options in developer mode
    if os.environ.get("ZESYSMAN_DEVELOPER_MODE"):
        parser.add_argument("-n", "--dry-run", action='store_true', help="do not make any state changes")
        parser.add_argument("--save-profile", metavar='PROF', help="save device configuration")
        parser.add_argument("--restore-profile", metavar='PROF', help="restore device configuration")
        parser.add_argument("--topo-matrix", action='store_true', help="show topology matrix")
        parser.add_argument("--subdevice", action='store_true', help="report by subdevice")
        parser.add_argument("--tiny-uuid", action='store_true', help="print tiny device UUIDs")
        parser.add_argument("--debug", action='store_true', help="debug (for development only)")
        parser.add_argument("--reset-freq", action='store_true', help="reset frequency limits")
        parser.add_argument("--show-timestamp", action='store_true',
                            help="show timestamps when iterating")
        parser.add_argument("--wait-events", nargs='*', metavar=('MSEC','MASK'), help="wait for events")
        parser.add_argument("--show-fans", action='store_true', help="show fans")
        parser.add_argument("--set-fan-speed-default", nargs=1, type=int, metavar='IDX',
                            help="set fan to default speed")
        parser.add_argument("--set-fan-speed-rpm", nargs=2, type=int, metavar=('IDX','RPM'),
                            help="set fan to fixed speed in RPM")
        parser.add_argument("--set-fan-speed-percent", nargs=2, type=int, metavar=('IDX','%'),
                            help="set fan to fixed speed in percent of max")
        parser.add_argument("--set-fan-speed-table-rpm", nargs='+', type=int, metavar=('IDX','N'),
                            help="set fan to temperature table in RPM")
        parser.add_argument("--set-fan-speed-table-percent", nargs='+', type=int, metavar=('IDX','N'),
                            help="set fan to temperature table in percent of max")
        parser.add_argument("--show-firmware", action='store_true', help="show firmware")
        parser.add_argument("--flash-firmware", nargs=1, metavar='FILE', help="flash firmware from FILE")
        parser.add_argument("--set-oc-freq", nargs=2, metavar=('IDX','FRQ'),
                            help="Set overclock frequency target")
        parser.add_argument("--set-oc-volts", nargs=3, metavar=('IDX','V','V'),
                            help="Set overclock voltage/offset targets")
        parser.add_argument("--set-oc-off", nargs=1, type=int, metavar='IDX',
                            help="Set overclock mode to OFF")
        parser.add_argument("--set-oc-override", nargs=1, type=int, metavar='IDX',
                            help="Set overclock mode to OVERRIDE")
        parser.add_argument("--set-oc-interpolate", nargs=1, type=int, metavar='IDX',
                            help="Set overclock mode to INTERPOLATING")
        parser.add_argument("--set-oc-fixed", nargs=1, type=int, metavar='IDX',
                            help="Set overclock mode to FIXED")
        parser.add_argument("--set-oc-max-current", nargs=2, metavar=('IDX','A'),
                            help="Set max overclock current")
        parser.add_argument("--set-oc-max-temp", nargs=2, metavar=('IDX','C'),
                            help="Set max overclock temperature")
        parser.add_argument("--show-oc", action='store_true', help="show overclocking")
        parser.add_argument("--show-leds", action='store_true', help="show leds")
        parser.add_argument("--enable-led", nargs=1, type=int, metavar='IDX', help="enable LED")
        parser.add_argument("--disable-led", nargs=1, type=int, metavar='IDX', help="disable LED")
        parser.add_argument("--set-led-color", nargs='+', metavar=('IDX','COLOR'), help="set LED color")
        parser.add_argument("--ansi-256", action='store_true', help="use ANSI-256 colors")
        parser.add_argument("--show-perf", action='store_true', help="show performance factors")
        parser.add_argument("--set-perf", nargs=2, metavar=('IDX','VAL'), help="set performance factor")
        parser.add_argument("--show-psu", action='store_true', help="show power supplies")

    args = parser.parse_args()

    if not os.environ.get("ZESYSMAN_DEVELOPER_MODE"):
        args.dry_run = None
        args.save_profile = None
        args.restore_profile = None
        args.topo_matrix = None
        args.subdevice = None
        args.tiny_uuid = None
        args.debug = None
        args.reset_freq = None
        args.wait_events = None
        args.show_fans = None
        args.set_fan_speed_default = None
        args.set_fan_speed_rpm = None
        args.set_fan_speed_percent = None
        args.set_fan_speed_table_rpm = None
        args.set_fan_speed_table_percent = None
        args.show_firmware = None
        args.flash_firmware = None
        args.set_oc_freq = None
        args.set_oc_volts = None
        args.set_oc_off = None
        args.set_oc_override = None
        args.set_oc_interpolate = None
        args.set_oc_fixed = None
        args.set_oc_max_current = None
        args.set_oc_max_temp = None
        args.show_oc = None
        args.show_leds = None
        args.enable_led = None
        args.disable_led = None
        args.set_led_color = None
        args.ansi_256 = None
        args.set_perf = None
        args.show_perf = None
        args.show_psu = None

    Node = formatArgClass.get(args.format, Node)

    unsupportedOpts = ["save_profile", "restore_profile"]
    unsupportedFlags = ["topo_matrix", "subdevice"]

    for field in unsupportedOpts:
        if args.__dict__.get(field) is not None:
            pr.fail(field.upper(), "option is not supported yet")

    for field in unsupportedFlags:
        if args.__dict__.get(field):
            pr.fail(field.upper(), "option is not supported yet")

    if args.poll is not None and args.iterations is not None:
        args.iterations = 0

    if args.iterations is not None:
        if args.iterations < 1:
            maxIterations = sys.maxint
        else:
            maxIterations = args.iterations

        args.show_telemetry = True

    if args.output and args.output != "-":
        if args.format is None:
            ext = os.path.splitext(args.output)[1].lower()
            Node = formatExtClass.get(ext, Node)
        try:
            fil = open(args.output, "w")
        except:
            pr.fail("Could not open file", args.output, "for writing")
        else:
            pr.outputFile = fil
            pr.teeOutput = args.tee

    if args.indent is not None:
        if args.indent >= 0:
            indentStr = " " * args.indent
        else:
            indentStr = "\t" * -args.indent

    if args.tiny_uuid:
        deviceUUID = tinyUUID

    if args.debug:
        pr.debugFile = sys.stderr

    condensedList = (args.style == "condensed")

    if args.uuid_index:
        IndexAttributes = SecondaryIndexAttributes
        SecondaryIndexAttributes = []

    if args.ansi_256:
        addAnsi256ColorBlock = True

    return args

def sigintHandler(sigNum, frame):
    global maxIterations
    maxIterations = 0

def parseMilliwatts(opts):
    value = 0.0
    multiplier = 1000.0
    remainder = []
    if opts:
        opt = opts.pop(0).lower()
        split = None
        if "m" in opt:
            split = opt.index("m")
        if "w" in opt:
            if split is None:
                split = opt.index("w")
            else:
                split = min(split, opt.index("w"))
        if split is None:
            rest = opts
        else:
            opt, rest = opt[:split], [opt[split:]] + opts

        try:
            value = float(opt)
        except:
            hitRemainder = True
            if opt not in ["d", "def", "default"]:
                pr.err("WARNING: Illegal power value (" + opt + "), using default/0")
        else:
            hitRemainder = False

        for opt in rest:
            opt = opt.lower()
            if hitRemainder:
                remainder.append(opt)
            else:
                hitRemainder = True
                if opt in ["m", "mw", "mwatt", "mwatts", "milliwatt", "milliwatts"]:
                    multiplier = 1.0
                elif opt not in ["w", "wt", "watt", "watts"]:
                    remainder.append(opt)
    else:
        pr.err("WARNING: No power value specified, using default/0")

    return int(value * multiplier), remainder

def parseMilliseconds(opts):
    value = 0.0
    multiplier = 1000.0
    remainder = []
    if opts:
        opt = opts.pop(0).lower()
        split = None
        if "m" in opt:
            split = opt.index("m")
        if "s" in opt:
            if split is None:
                split = opt.index("s")
            else:
                split = min(split, opt.index("s"))
        if split is None:
            rest = opts
        else:
            opt, rest = opt[:split], [opt[split:]] + opts

        try:
            value = float(opt)
        except:
            hitRemainder = True
            if opt not in ["d", "def", "default"]:
                pr.err("WARNING: Illegal time value (" + opt + "), using default/0")
        else:
            hitRemainder = False

        for opt in rest:
            opt = opt.lower()
            if hitRemainder:
                remainder.append(opt)
            else:
                hitRemainder = True
                if opt in ["m", "ms", "msec", "msecond", "mseconds", "millisecond", "milliseconds"]:
                    multiplier = 1.0
                elif opt not in ["s", "sec", "second", "seconds"]:
                    remainder.append(opt)
    else:
        pr.err("WARNING: No time value specified, using default/0")

    return int(value * multiplier), remainder

def parseJoules(opts):
    value = 0.0
    multiplier = 1.0
    remainder = []
    if opts:
        opt = opts.pop(0).lower()
        split = None
        if "m" in opt:
            split = opt.index("m")
        if "k" in opt:
            if split is None:
                split = opt.index("k")
            else:
                split = min(split, opt.index("k"))
        if "j" in opt:
            if split is None:
                split = opt.index("j")
            else:
                split = min(split, opt.index("j"))
        if split is None:
            rest = opts
        else:
            opt, rest = opt[:split], [opt[split:]] + opts

        try:
            value = float(opt)
        except:
            hitRemainder = True
            pr.err("WARNING: Illegal energy value (" + opt + "), using 0.0 J")
        else:
            hitRemainder = False

        for opt in rest:
            opt = opt.lower()
            if hitRemainder:
                remainder.append(opt)
            else:
                hitRemainder = True
                if opt in ["m", "mj", "mjoule", "mjoules", "millijoule", "millijoules"]:
                    multiplier = 0.001
                elif opt in ["k", "kj", "kjoule", "kjoules", "kilojoule", "kilojoules"]:
                    multiplier = 1000.0
                elif opt in ["j", "joule", "joules"]:
                    remainder.append(opt)
    else:
        pr.err("WARNING: No energy value specified, using 0.0 J")

    return value * multiplier, remainder

def parseMHz(opts):
    value = 0.0
    multiplier = 1.0
    remainder = []
    if opts:
        opt = opts.pop(0).lower()
        split = None
        if "m" in opt:
            split = opt.index("m")
        if "g" in opt:
            if split is None:
                split = opt.index("g")
            else:
                split = min(split, opt.index("g"))
        if "h" in opt:
            if split is None:
                split = opt.index("h")
            else:
                split = min(split, opt.index("h"))
        if "k" in opt:
            if split is None:
                split = opt.index("k")
            else:
                split = min(split, opt.index("k"))
        if split is None:
            rest = opts
        else:
            opt, rest = opt[:split], [opt[split:]] + opts

        try:
            value = float(opt)
        except:
            hitRemainder = True
            if opt not in ["d", "def", "default"]:
                pr.err("WARNING: Illegal power value (" + opt + "), using default/0")
        else:
            hitRemainder = False

        for opt in rest:
            opt = opt.lower()
            if hitRemainder:
                remainder.append(opt)
            else:
                hitRemainder = True
                if opt in ["g", "ghz", "gigahertz"]:
                    multiplier = 1000.0
                elif opt in ["k", "khz", "kilohertz"]:
                    multiplier = 1e-3
                elif opt in ["h", "hz", "hertz"]:
                    multiplier = 1e-6
                elif opt not in ["m", "mhz", "megahertz"]:
                    remainder.append(opt)
    else:
        pr.err("WARNING: No power value specified, using default/0")

    return value * multiplier, remainder

def parseSchedulerMode(opts):
    opt, remainder = opts[0].lower(), opts[1:]

    if opt in ["timeout", "time", "to", "t", "zes_sched_mode_timeout"]:
        mode = ZES_SCHED_MODE_TIMEOUT
    elif opt in ["timeslice", "slice", "ts", "s", "zes_sched_mode_timeslice"]:
        mode = ZES_SCHED_MODE_TIMESLICE
    elif opt in ["exclusive", "exc", "ex", "e", "x", "zes_sched_mode_exclusive"]:
        mode = ZES_SCHED_MODE_EXCLUSIVE
    elif opt in ["cudebug", "debug", "dbg", "db", "d", "g", "zes_sched_mode_compute_unit_debug"]:
        mode = ZES_SCHED_MODE_COMPUTE_UNIT_DEBUG
    else:
        pr.err("ERROR: Unrecognized scheduler mode", opt)
        raise ValueError(opt)

    return mode, remainder

def parseMicroseconds(opts):
    value = 0.0
    multiplier = 1000000.0
    remainder = []
    if opts:
        opt = opts.pop(0).lower()
        split = None
        if "u" in opt:
            split = opt.index("u")
        if "m" in opt:
            split = opt.index("m")
        if "s" in opt:
            if split is None:
                split = opt.index("s")
            else:
                split = min(split, opt.index("s"))
        if split is None:
            rest = opts
        else:
            opt, rest = opt[:split], [opt[split:]] + opts

        hitRemainder = True

        if opt in ["n", "none"]:
            value = ZES_SCHED_WATCHDOG_DISABLE
            multiplier = 1
        elif opt not in ["d", "def", "default"]:
            try:
                value = float(opt)
                hitRemainder = False
            except:
                pr.err("WARNING: Illegal time value (" + opt + "), using default")

        for opt in rest:
            opt = opt.lower()
            if hitRemainder:
                remainder.append(opt)
            else:
                hitRemainder = True
                if opt in ["u", "us", "usec", "usecond", "useconds", "microsecond", "microseconds"]:
                    multiplier = 1.0
                elif opt in ["m", "ms", "msec", "msecond", "mseconds", "millisecond", "milliseconds"]:
                    multiplier = 1000.0
                elif opt not in ["s", "sec", "second", "seconds"]:
                    remainder.append(opt)

    return int(value * multiplier), remainder

def findTestSuite(diagCount, diags, name):
    diagProps = zes_typed_structure(ZES_STRUCTURE_TYPE_DIAG_PROPERTIES)
    match = None
    for i in range(diagCount):
        diag = diags[i]
        zeCall(zesDiagnosticsGetProperties(diag, diagProps))
        # TODO: should we allow regexp matching?
        if name == diagProps.name:
            if match is None:
                match = i
            else:
                pr.err("ERROR:", name, "does not specify one test suite exactly, use index form")
                raise ValueError(name)

    if match is None:
        pr.err("ERROR:", name, "does not match any test suite name")
        raise ValueError(name)

    return match

def parseTestSuite(diagCount, diags, opts):
    opt_string = " ".join(opts)
    suite = opts.pop(0)
    try:
        i = int(suite, 0)
        assert(i < diagCount)
    except:
        i = findTestSuite(diagCount, diags, suite)

    diag = diags[i]

    if opts:
        try:
            first = int(opts.pop(0), 0)
            if opts:
                last = int(opts.pop(0), 0)
            else:
                last = first
            assert(not opts)
        except:
            pr.err("ERROR:", opt_string, "should be of form SUITE [N [N]]")
            raise ValueError(opts)
        else:
            diagProps = zes_typed_structure(ZES_STRUCTURE_TYPE_DIAG_PROPERTIES)
            zeCall(zesDiagnosticsGetProperties(diag, diagProps))
            if diagProps.haveTests:
                firstFound, lastFound = False, False
                testCount = uint32_ptr()
                try:
                    zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), None))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
                else:
                    tests = zes_diag_test_array(testCount.value())
                    zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), tests.cast()))
                    for t in range(testCount.value()):
                        test = tests[t]
                        if test.index == first:
                            firstFound = True
                        if test.index == last:
                            lastFound = True
                if not firstFound and first != ZES_DIAG_FIRST_TEST_INDEX:
                    pr.err("WARNING:", first, "not found in test suite")
                if not lastFound and last != first and ((last & 0xffffffff) !=
                                                        (ZES_DIAG_LAST_TEST_INDEX & 0xffffffff)):
                    pr.err("WARNING:", last, "not found in test suite")
            else:
                pr.err("WARNING: Test suite has no individual subtests")
    else:
        first, last = ZES_DIAG_FIRST_TEST_INDEX, ZES_DIAG_LAST_TEST_INDEX

    return diag, first, last

#
# Main program
#
def main():
    global deviceUUID, maxIterations, Node

    args = parseArgs()

    if maxIterations > 1:
        signal.signal(signal.SIGINT, sigintHandler)

    driverIndices, drivers = getDrivers(args.driver)

    deviceIDs, deviceUUIDs, devices = getDevices(driverIndices, drivers, args.device)

    generatingDeviceReport = False

    if args.show_all:
        args.show_temp, args.show_power, args.show_freq, args.show_util = True, True, True, True
        args.show_mem, args.show_pci, args.show_fabric_ports = True, True, True
        args.show_standby, args.show_errors = True, True

    if (args.show_device or args.show_processes or args.show_scheduler or args.show_temp or
        args.show_power or args.show_freq or args.show_util or args.show_mem or args.show_pci or
        args.show_fabric_ports or args.show_standby or args.show_errors or args.show_diag or
        args.show_fans or args.show_firmware or args.show_oc or args.show_leds or args.show_perf or
        args.show_psu):

        generatingDeviceReport = True

        if not args.show_inventory:
            args.show_telemetry = True

    elif args.show_inventory or args.show_telemetry:

        args.show_temp, args.show_power, args.show_freq, args.show_util = True, True, True, True
        args.show_mem, args.show_pci, args.show_fabric_ports = True, True, True
        args.show_standby, args.show_errors = True, True

        generatingDeviceReport = True

    if not generatingDeviceReport:
        Node = FormatNode

    if args.poll and args.poll > 0 and args.poll <= 60:
        pollInterval = args.poll
    else:
        pollInterval = 1

    pollDelayRequired = False
    telemetryClosures = []

    if args.reset:
        if len(devices) != 1:
            pr.fail("Cannot reset more than one GPU at a time")

        deviceName = "%s [%s]" % (deviceIDs[0], deviceUUID(deviceUUIDs[0]))

        if not args.yes:
            answer = input("Do you really want to reset device " + deviceName + "? ")
            args.yes = answer.lower() in ("y", "yes")

        if args.yes:
            if args.dry_run:
                pr("Would RESET device", deviceName)
            else:
                pr("RESETTING device", deviceName)
                zeCall(zesDeviceReset(devices[0], args.force))
        else:
            pr("NOT resetting device")

        sys.exit(0)

    if args.run_diag:
        if len(devices) != 1:
            pr.fail("Cannot test more than one GPU at a time")

        diagCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumDiagnosticTestSuites(devices[0], diagCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            diags = zes_diag_handle_array(diagCount.value())
            zeCall(zesDeviceEnumDiagnosticTestSuites(devices[0], diagCount.cast(), diags.cast()))

        suite, first, last = parseTestSuite(diagCount.value(), diags, args.run_diag)

        if args.dry_run:
            deviceName = "%s [%s]" % (deviceIDs[0], deviceUUID(deviceUUIDs[0]))
            pr("Would run diagnostics on device", deviceName)
        else:
            result = zeCall(zesDiagnosticsRunTests(suite, first, last))
            pr("Diagnostic test result:", diagResultString(result))

        sys.exit(result)

    if args.wait_events is not None:
        if len(driverIndices) != 1:
            pr.err("ERROR: can only wait on events from one driver at a time")
            sys.exit(1)

        allEvents = (ZES_EVENT_TYPE_FLAG_DEVICE_DETACH | ZES_EVENT_TYPE_FLAG_DEVICE_ATTACH |
                     ZES_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_ENTER |
                     ZES_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_EXIT | ZES_EVENT_TYPE_FLAG_FREQ_THROTTLED |
                     ZES_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED | ZES_EVENT_TYPE_FLAG_TEMP_CRITICAL |
                     ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD1 | ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD2 |
                     ZES_EVENT_TYPE_FLAG_MEM_HEALTH | ZES_EVENT_TYPE_FLAG_FABRIC_PORT_HEALTH |
                     ZES_EVENT_TYPE_FLAG_PCI_LINK_HEALTH | ZES_EVENT_TYPE_FLAG_RAS_CORRECTABLE_ERRORS |
                     ZES_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS |
                     ZES_EVENT_TYPE_FLAG_DEVICE_RESET_REQUIRED)

        if len(args.wait_events) > 1:
            selectedEvents = int(args.wait_events[1],0) & allEvents
        else:
            selectedEvents = allEvents

        for device in devices:
            try:
                zeCall(zesDeviceEventRegister(device, selectedEvents))
            except NotImplementedError:
                pass
            except ValueError:
                reportZeException()

        driver = drivers[0]
        if len(args.wait_events) > 0:
            timeout = int(args.wait_events[0],0) & 0xffffffff
        else:
            timeout = 1000
        count = len(devices)
        phDevices = ze_device_handle_array(count)
        for i, device in indexed(devices):
            phDevices[i] = device
        pEvents = zes_event_type_flags_array(count)

        try:
            numEvents = zeCall(zesDriverEventListen(driver, timeout, count, phDevices.cast(), pEvents.cast()))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            if numEvents:
                pr(numEvents, "device(s) reported events:")
                for i in range(count):
                    events = eventsString(pEvents[i])
                    pr("   ", deviceIDs[i], ":", deviceUUIDs[i], events)
            else:
                pr("No events reported")

        for device in devices:
            try:
                zeCall(zesDeviceEventRegister(device, 0))
            except NotImplementedError:
                pass
            except ValueError:
                reportZeException()

        sys.exit(0)

    if args.ascii:
        degC = "degC"
    else:
        degC = "°C"

    topNode = Node(None, "Devices", None)

    for devID, devUUID, device in zip(deviceIDs, deviceUUIDs, devices):
        devNode = Node(topNode, "Device", None, ("Index", devID), ("UUID", deviceUUID(devUUID)))
        if args.show_device:
            coreProps = ze_typed_structure(ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES)
            zeCall(zeDeviceGetProperties(device, coreProps))
            Node(devNode, "Name", coreProps.name)
            Node(devNode, "Type", deviceTypeString(coreProps.type))
            Node(devNode, "VendorId", hex(coreProps.vendorId))
            Node(devNode, "DeviceId", hex(coreProps.deviceId))
            if args.show_inventory:
                try:
                    props = zes_typed_structure(ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES)
                    zeCall(zesDeviceGetProperties(device, props))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
                else:
                    Node(devNode, "NumSubdevices", props.numSubdevices)
                    Node(devNode, "serialNumber", props.serialNumber)
                    Node(devNode, "boardNumber", props.boardNumber)
                    Node(devNode, "brandName", props.brandName)
                    Node(devNode, "modelName", props.modelName)
                    Node(devNode, "vendorName", props.vendorName)
                    Node(devNode, "driverVersion", props.driverVersion)
                    if args.verbose:
                        Node(devNode, "coreClockRate", props.core.coreClockRate, ("Units", "MHz"))
                        Node(devNode, "maxMemAllocSize", props.core.maxMemAllocSize)
                        Node(devNode, "maxHardwareContexts", props.core.maxHardwareContexts)
                        Node(devNode, "timestampValidBits", props.core.timestampValidBits)
                        Node(devNode, "kernelTimestampValidBits", props.core.kernelTimestampValidBits)
                        Node(devNode, "maxCommandQueuePriority", props.core.maxCommandQueuePriority)
                        Node(devNode, "numThreadsPerEU", props.core.numThreadsPerEU)
                        Node(devNode, "physicalEUSimdWidth", props.core.physicalEUSimdWidth)
                        Node(devNode, "numEUsPerSubslice", props.core.numEUsPerSubslice)
                        Node(devNode, "numSubslicesPerSlice", props.core.numSubslicesPerSlice)
                        Node(devNode, "numSlices", props.core.numSlices)
                        Node(devNode, "timerResolution", props.core.timerResolution)

            if args.show_telemetry:
                nodes = []
                nodes.append(Node(devNode, "ResetReasons", "?"))
                nodes.append(Node(devNode, "RepairStatus", "?"))

                def deviceTelemetry(device=device, nodes=nodes):
                    state = zes_typed_structure(ZES_STRUCTURE_TYPE_DEVICE_STATE)
                    try:
                        zeCall(zesDeviceGetState(device, state))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        reportZeException()
                    else:
                        nodes[0].setText(resetReasonsString(state.reset))
                        nodes[1].setText(repairStatusString(state.repaired))

                telemetryClosures.append(deviceTelemetry)

        tempCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumTemperatureSensors(device,tempCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            temperatures = zes_temp_handle_array(tempCount.value())
            zeCall(zesDeviceEnumTemperatureSensors(device,tempCount.cast(), temperatures.cast()))

        if args.enable_critical_temp:
            t, = args.enable_critical_temp
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.enableCritical = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_critical_temp:
            t, = args.disable_critical_temp
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.enableCritical = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t1_low_to_high:
            t, = args.enable_t1_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableLowToHigh = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t1_low_to_high:
            t, = args.disable_t1_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableLowToHigh = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t1_high_to_low:
            t, = args.enable_t1_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableHighToLow = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t1_high_to_low:
            t, = args.disable_t1_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableHighToLow = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.set_t1_threshold:
            t,v = args.set_t1_threshold
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.threshold = v
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t2_low_to_high:
            t, = args.enable_t2_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableLowToHigh = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t2_low_to_high:
            t, = args.disable_t2_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableLowToHigh = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t2_high_to_low:
            t, = args.enable_t2_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableHighToLow = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t2_high_to_low:
            t, = args.disable_t2_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableHighToLow = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.set_t2_threshold:
            t,v = args.set_t2_threshold
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.threshold = v
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")

        if args.show_temp:
            tempTop = Node(devNode, "TemperatureSensors", None)

            for i in range(tempCount.value()):
                temp = temperatures[i]
                tempProps = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_PROPERTIES)
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetProperties(temp, tempProps))
                except NotImplementedError:
                    continue
                except ValueError:
                    reportZeException()
                    continue
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
                tempType = tempTypeString(tempProps.type)
                if tempProps.onSubdevice:
                    tempNode = Node(tempTop, "TemperatureSensor", None, ("Index", i), ("Name", tempType),
                                    ("SubdeviceId", tempProps.subdeviceId))
                else:
                    tempNode = Node(tempTop, "TemperatureSensor", None, ("Index", i), ("Name", tempType))

                if args.show_inventory:
                    Node(tempNode, "MaxTemperature", "%.1f" % tempProps.maxTemperature, ("Units", degC))
                    if tempProps.isCriticalTempSupported:
                        Node(tempNode, "CriticalTempEnabled", bool(tempConfig.enableCritical))
                    if tempProps.isThreshold1Supported:
                        t1Node = Node(tempNode, "Threshold1", None)
                        Node(t1Node, "EnabledLowToHigh", bool(tempConfig.threshold1.enableLowToHigh))
                        Node(t1Node, "EnabledHighToLow", bool(tempConfig.threshold1.enableHighToLow))
                        Node(t1Node, "Threshold", "%.1f" % tempConfig.threshold1.threshold,
                             ("Units", degC))
                    if tempProps.isThreshold2Supported:
                        t2Node = Node(tempNode, "Threshold2", None)
                        Node(t2Node, "EnabledLowToHigh", bool(tempConfig.threshold2.enableLowToHigh))
                        Node(t2Node, "EnabledHighToLow", bool(tempConfig.threshold2.enableHighToLow))
                        Node(t2Node, "Threshold", "%.1f" % tempConfig.threshold2.threshold,
                             ("Units", degC))

                if args.show_telemetry:
                    node = Node(tempNode, "Current", "?", ("Units", degC))

                    def tempTelemetry(temp=temp, node=node, degC=degC):
                        try:
                            tempCurrent = zeCall(zesTemperatureGetState(temp))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            reportZeException()
                        else:
                            node.setText("%.1f" % tempCurrent)

                    telemetryClosures.append(tempTelemetry)

        pwrCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumPowerDomains(device,pwrCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            powers = zes_pwr_handle_array(pwrCount.value())
            zeCall(zesDeviceEnumPowerDomains(device, pwrCount.cast(), powers.cast()))

        if args.set_power or args.set_burst_power or args.set_peak_power:
            sustainedLimit = None
            burstLimit = None
            peakLimit = None
            if args.set_power:
                sustainedLimit = zes_power_sustained_limit_t()
                sustainedLimit.enabled = True
                sustainedLimit.power, remainder = parseMilliwatts(args.set_power)
                sustainedLimit.interval, remainder = parseMilliseconds(remainder)
                if remainder:
                    pr.err("WARNING: Extra set-power arguments ignored")
            if args.set_burst_power:
                burstLimit = zes_power_burst_limit_t()
                burstLimit.enabled = True
                burstLimit.power, remainder = parseMilliwatts(args.set_burst_power)
                if remainder:
                    pr.err("WARNING: Extra set-burst-power arguments ignored")
            if args.set_peak_power:
                peakLimit = zes_power_peak_limit_t()
                peakLimit.powerAC, remainder = parseMilliwatts(args.set_peak_power)
                peakLimit.powerDC, remainder = parseMilliwatts(remainder)
                if remainder:
                    pr.err("WARNING: Extra set-peak-power arguments ignored")
            for i in range(pwrCount.value()):
                pwr = powers[i]
                if args.dry_run:
                    if sustainedLimit:
                        pr("Would set sustained limit to", sustainedLimit.power, "mW,",
                           sustainedLimit.interval, "ms")
                    if burstLimit:
                        pr("Would set burst limit to", burstLimit.power, "mW")
                    if peakLimit:
                        pr("Would set peak AC, DC limits to", peakLimit.powerAC, "mW,",
                           peakLimit.powerDC, "mW")
                else:
                    zeCall(zesPowerSetLimits(pwr, sustainedLimit, burstLimit, peakLimit))

        if args.set_energy_threshold:
            threshold, remainder = parseJoules(args.set_energy_threshold)
            for i in range(pwrCount.value()):
                pwr = powers[i]
                if args.dry_run:
                    pr("Would set energy threshold to", threshold, "J")
                else:
                    zeCall(zesPowerSetEnergyThreshold(pwr, threshold))

        if args.show_power:
            pwrTop = Node(devNode, "PowerDomains", None)

            for i in range(pwrCount.value()):
                pwr = powers[i]
                pwrProps = zes_typed_structure(ZES_STRUCTURE_TYPE_POWER_PROPERTIES)
                zeCall(zesPowerGetProperties(pwr, pwrProps))
                if pwrProps.onSubdevice:
                    pwrNode = Node(pwrTop, "PowerDomain", None, ("Index", i), ("Name", "Subdevice"),
                                      ("SubdeviceId", pwrProps.subdeviceId))
                else:
                    pwrNode = Node(pwrTop, "PowerDomain", None, ("Index", i), ("Name", "Package"))

                if args.show_inventory:
                    if args.verbose:
                        Node(pwrNode, "CanControl", bool(pwrProps.canControl))
                        Node(pwrNode, "ThresholdSupported", bool(pwrProps.isEnergyThresholdSupported))
                        Node(pwrNode, "DefaultLimit", fmtknown(pwrProps.defaultLimit / 1000, "%.3f"),
                             ("Units", "Watts"))
                        Node(pwrNode, "MinLimit", fmtknown(pwrProps.minLimit / 1000, "%.3f"),
                             ("Units", "Watts"))
                        Node(pwrNode, "MaxLimit", fmtknown(pwrProps.maxLimit / 1000, "%.3f"),
                             ("Units", "Watts"))

                    sustainedLimit = zes_power_sustained_limit_t()
                    burstLimit = zes_power_burst_limit_t()
                    peakLimit = zes_power_peak_limit_t()
                    zeCall(zesPowerGetLimits(pwr, sustainedLimit, burstLimit, peakLimit))
                    sustainedNode = Node(pwrNode, "SustainedLimit", None)
                    Node(sustainedNode, "Enabled", bool(sustainedLimit.enabled))
                    Node(sustainedNode, "Power", "%.3f" % (sustainedLimit.power / 1000),
                         ("Units", "Watts"))
                    Node(sustainedNode, "Interval", "%.3f" % (sustainedLimit.interval / 1000),
                         ("Units", "sec"))
                    burstNode = Node(pwrNode, "BurstLimit", None)
                    Node(burstNode, "Enabled", bool(burstLimit.enabled))
                    Node(burstNode, "Power", "%.3f" % (burstLimit.power / 1000), ("Units", "Watts"))
                    peakNode = Node(pwrNode, "PeakLimit", None)
                    Node(peakNode, "Power", "%.3f" % (peakLimit.powerAC / 1000), ("Units", "Watts"))
                    if peakLimit.powerDC > 0:
                        Node(peakNode, "PowerOnDC", "%.3f" % (peakLimit.powerDC / 1000),
                             ("Units", "Watts"))

                if args.show_telemetry:
                    pwrCounter = zes_power_energy_counter_t()
                    pwrThreshold = zes_energy_threshold_t()
                    zeCall(zesPowerGetEnergyCounter(pwr, pwrCounter))
                    nodes = []
                    nodes.append(Node(pwrNode, "CurrentPower", "?", ("Units", "Watts")))
                    nodes.append(Node(pwrNode, "MonitorProcess", "?"))
                    nodes.append(Node(pwrNode, "EnergyThreshold", "?", ("Units", "Joules")))

                    def pwrTelemetry(pwr=pwr, pwrCounter=pwrCounter, pwrThreshold=pwrThreshold, node=nodes):
                        oldEnergy, oldTimestamp = pwrCounter.energy, pwrCounter.timestamp
                        zeCall(zesPowerGetEnergyCounter(pwr, pwrCounter))
                        deltaE = pwrCounter.energy - oldEnergy
                        deltaT = pwrCounter.timestamp - oldTimestamp
                        if deltaT > 0:
                            watts = "%.3f" % (float(deltaE) / deltaT)
                        else:
                            watts = "?"
                        node[0].setText(watts)
                        zeCall(zesPowerGetEnergyThreshold(pwr, pwrThreshold))
                        if pwrThreshold.enable:
                            if pwrThreshold.processId != 0xffffffff:
                                node[1].setText(pwrThreshold.processId)
                            else:
                                node[1].setText("Unknown")
                        else:
                            node[1].setText("None")
                        node[2].setText("%.3f" % pwrThreshold.threshold)

                    telemetryClosures.append(pwrTelemetry)
                    pollDelayRequired = True

        freqCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFrequencyDomains(device, freqCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            frequencies = zes_freq_handle_array(freqCount.value())
            zeCall(zesDeviceEnumFrequencyDomains(device, freqCount.cast(), frequencies.cast()))

        if args.set_freq or args.reset_freq:
            for i in range(freqCount.value()):
                freqRange = zes_freq_range_t()
                if args.reset_freq:
                    freqRange.min = 0
                    freqRange.max = 0
                if args.set_freq:
                    freqRange.min, remainder = parseMHz(args.set_freq)
                    if remainder:
                        freqRange.max, remainder = parseMHz(remainder)
                        if remainder:
                            pr.err("WARNING: Extra set-freq arguments ignored")
                    else:
                        freqRange.max = freqRange.min
                freq = frequencies[i]
                if args.dry_run:
                    pr("Would set frequency range to", freqRange.min, "MHz -", freqRange.max, "MHz")
                else:
                    zeCall(zesFrequencySetRange(freq, freqRange))

        if args.show_freq:
            freqTop = Node(devNode, "FrequencyDomains", None)

            for i in range(freqCount.value()):
                freq = frequencies[i]
                freqProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FREQ_PROPERTIES)
                zeCall(zesFrequencyGetProperties(freq, freqProps))
                freqType = freqTypeString(freqProps.type)
                if freqProps.onSubdevice:
                    freqNode = Node(freqTop, "FrequencyDomain", None, ("Index", i), ("Name", freqType),
                                       ("SubdeviceId", freqProps.subdeviceId))
                else:
                    freqNode = Node(freqTop, "FrequencyDomain", None, ("Index", i), ("Name", freqType))

                if args.show_inventory:
                    if args.verbose:
                        Node(freqNode, "CanControl", bool(freqProps.canControl))
                        Node(freqNode, "ThrottleEventSupported",
                             bool(freqProps.isThrottleEventSupported))
                    availFreqsNode = Node(freqNode, "AvailableFrequencies", None)
                    Node(availFreqsNode, "Min", "%.1f" % freqProps.min, ("Units", "MHz"))
                    Node(availFreqsNode, "Max", "%.1f" % freqProps.max, ("Units", "MHz"))
                    if args.verbose:
                        clockCount = uint32_ptr()
                        try:
                            zeCall(zesFrequencyGetAvailableClocks(freq, clockCount.cast(), None))
                        except:
                            pass
                        else:
                            clockFreqs = double_array(clockCount.value())
                            zeCall(zesFrequencyGetAvailableClocks(freq, clockCount.cast(), clockFreqs.cast()))
                        for clk in range(clockCount.value()):
                            clockFreq = clockFreqs[clk]
                            Node(availFreqsNode, "AvailableFrequency", "%.1f" % clockFreq,
                                 ("Units", "MHz"))

                    freqRange = zes_freq_range_t()
                    zeCall(zesFrequencyGetRange(freq, freqRange))
                    rangeFreqsNode = Node(freqNode, "FrequencyRange", None)
                    Node(rangeFreqsNode, "Min", "%.1f" % freqRange.min, ("Units", "MHz"))
                    Node(rangeFreqsNode, "Max", "%.1f" % freqRange.max, ("Units", "MHz"))

                if args.show_telemetry:
                    freqState = zes_typed_structure(ZES_STRUCTURE_TYPE_FREQ_STATE)
                    freqThrottle = zes_freq_throttle_time_t()
                    try:
                        zeCall(zesFrequencyGetThrottleTime(freq, freqThrottle))
                    except NotImplementedError:
                        freqThrottle = None
                    except ValueError:
                        reportZeException()
                    nodes = []
                    nodes.append(Node(freqNode, "RequestedFrequency", "?", ("Units", "MHz")))
                    nodes.append(Node(freqNode, "ActualFrequency", "?", ("Units", "MHz")))
                    nodes.append(Node(freqNode, "ThrottleReasons", "?"))
                    nodes.append(Node(freqNode, "ThrottleTime", "?", ("Units", "%")))
                    if args.verbose:
                        nodes.append(Node(freqNode, "CurrentVoltage", "?", ("Units", "Volts")))
                        nodes.append(Node(freqNode, "Efficient", "?", ("Units", "MHz")))
                        nodes.append(Node(freqNode, "MaximumTDP", "?", ("Units", "MHz")))

                    def freqTelemetry(freq=freq, freqState=freqState, freqThrottle=freqThrottle,
                                      node=nodes, verbose=args.verbose):
                        throttlePercent = "?"
                        if freqThrottle:
                            oldHeld, oldTimestamp = freqThrottle.throttleTime, freqThrottle.timestamp
                            try:
                                zeCall(zesFrequencyGetThrottleTime(freq, freqThrottle))
                            except:
                                reportZeException()
                            else:
                                deltaH = freqThrottle.throttleTime - oldHeld
                                deltaT = freqThrottle.timestamp - oldTimestamp
                                if deltaT > 0:
                                    throttlePercent = "%.0f" % (100.0 * deltaH / deltaT)
                                else:
                                    throttlePercent = "?"
                        zeCall(zesFrequencyGetState(freq, freqState))
                        node[0].setText(fmtknown(freqState.request))
                        node[1].setText(fmtknown(freqState.actual))
                        node[2].setText(throttleReasonsString(freqState.throttleReasons))
                        node[3].setText(throttlePercent)
                        if verbose:
                            node[4].setText(fmtknown(freqState.currentVoltage))
                            node[5].setText(fmtknown(freqState.efficient))
                            node[6].setText(fmtknown(freqState.tdp))

                    telemetryClosures.append(freqTelemetry)
                    pollDelayRequired = True

        # TODO: Use generalized parsing methods that support units

        if args.set_oc_freq:
            idxStr, frqStr = args.set_oc_freq
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                frqMHz = float(frqStr)
            except:
                pr.fail("Usage: --set-oc-freq IDX FREQ")
            if args.dry_run:
                pr("Would set oc", i, "frequency target to", frqMHz, "MHz")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    frqMHz = saturate(frqMHz, 0.0, ocCaps.maxOcFrequency)
                    zeCall(zesFrequencyOcSetFrequencyTarget(freq, frqMHz))
                except:
                    pr.fail("--set-oc-freq not supported")

        if args.set_oc_volts:
            idxStr, vTargetStr, vOffsetStr = args.set_oc_volts
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                vTarget = float(vTargetStr)
                vOffset = float(vOffsetStr)
            except:
                pr.fail("Usage: --set-oc-volts IDX VOLTAGE_TARGET VOLTAGE_OFFSET")
            if args.dry_run:
                pr("Would set oc", i, "voltage target to", vTarget, "V, offset", vOffset, "V")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    vTarget = saturate(vTarget, 0.0, ocCaps.maxOcVoltage)
                    vOffset = saturate(vOffset, ocCaps.minOcVoltageOffset, ocCaps.maxOcVoltageOffset)
                    zeCall(zesFrequencyOcSetVoltageTarget(freq, vTarget, vOffset))
                except:
                    pr.fail("--set-oc-volts not supported")

        if args.set_oc_off:
            idxStr, = args.set_oc_off
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-off IDX")
            if args.dry_run:
                pr("Would set oc", i, "mode to OFF")
            else:
                try:
                    freq = frequencies[i]
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_OFF))
                except:
                    pr.fail("--set-oc-off not supported")

        if args.set_oc_override:
            idxStr, = args.set_oc_override
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-override IDX")
            if args.dry_run:
                pr("Would set oc", i, "mode to OVERRIDE")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_OVERRIDE))
                except:
                    pr.fail("--set-oc-override not supported")

        if args.set_oc_interpolate:
            idxStr, = args.set_oc_interpolate
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-interpolate IDX")
            if args.dry_run:
                pr("Would set oc", i, "mode to INTERPOLATIVE")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_INTERPOLATIVE))
                except:
                    pr.fail("--set-oc-interpolate not supported")

        if args.set_oc_fixed:
            idxStr, = args.set_oc_fixed
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-interpolate IDX")
            if args.dry_run:
                pr("Would set oc", i, "mode to FIXED")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported and ocCaps.isFixedModeSupported
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_FIXED))
                except:
                    pr.fail("--set-oc-interpolate not supported")

        if args.set_oc_max_current:
            idxStr, iccStr = args.set_oc_max_current
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                iccAmps = float(iccStr)
            except:
                pr.fail("Usage: --set-oc-max-current IDX MAX_AMPS")
            if args.dry_run:
                pr("Would set oc", i, "maximum current to", iccAmps, "MHz")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported and ocCaps.isIccMaxSupported
                    zeCall(zesFrequencyOcSetIccMax(freq, iccAmps))
                except:
                    pr.fail("--set-oc-max-current not supported")

        if args.set_oc_max_temp:
            idxStr, tempStr = args.set_oc_max_temp
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                tempC = float(tempStr)
            except:
                pr.fail("Usage: --set-oc-max-temp IDX MAX_DEG_C")
            if args.dry_run:
                pr("Would set oc", i, "maximum temperature to", tempC, "MHz")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported and ocCaps.isTjMaxSupported
                    zeCall(zesFrequencyOcSetTjMax(freq, tempC))
                except:
                    pr.fail("--set-oc-max-temp not supported")

        if args.show_oc:
            ocTop = Node(devNode, "OverclockDomains", None)

            for i in range(freqCount.value()):
                freq = frequencies[i]
                ocNode = None
                try:
                    freqProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FREQ_PROPERTIES)
                    zeCall(zesFrequencyGetProperties(freq, freqProps))
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
                else:
                    freqType = freqTypeString(freqProps.type)
                    if freqProps.onSubdevice:
                        ocNode = Node(ocTop, "OverclockDomain", None, ("Index", i), ("Name", freqType),
                                           ("SubdeviceId", freqProps.subdeviceId))
                    else:
                        ocNode = Node(ocTop, "OverclockDomain", None, ("Index", i), ("Name", freqType))

                if ocNode and args.show_inventory:
                    try:
                        mode = zeCall(zesFrequencyOcGetMode(freq))
                    except:
                        mode = ZES_OC_MODE_OFF
                    Node(ocNode, "OverclockingMode", ocModeString(mode))
                    Node(ocNode, "isOcSupported", bool(ocCaps.isOcSupported))
                    Node(ocNode, "maxFactoryDefaultFrequency", "%.1f" % ocCaps.maxFactoryDefaultFrequency,
                         ("Units", "MHz"))
                    Node(ocNode, "maxFactoryDefaultVoltage", "%.1f" % ocCaps.maxFactoryDefaultVoltage,
                         ("Units", "V"))
                    Node(ocNode, "maxOcFrequency", "%.1f" % ocCaps.maxOcFrequency, ("Units", "MHz"))
                    Node(ocNode, "minOcVoltageOffset", "%.1f" % ocCaps.minOcVoltageOffset, ("Units", "V"))
                    Node(ocNode, "maxOcVoltageOffset", "%.1f" % ocCaps.maxOcVoltageOffset, ("Units", "V"))
                    Node(ocNode, "maxOcVoltage", "%.1f" % ocCaps.maxOcVoltage, ("Units", "V"))
                    Node(ocNode, "isTjMaxSupported", bool(ocCaps.isTjMaxSupported))
                    Node(ocNode, "isIccMaxSupported", bool(ocCaps.isIccMaxSupported))
                    Node(ocNode, "isHighVoltModeCapable", bool(ocCaps.isHighVoltModeCapable))
                    Node(ocNode, "isHighVoltModeEnabled", bool(ocCaps.isHighVoltModeEnabled))
                    Node(ocNode, "isExtendedModeSupported", bool(ocCaps.isExtendedModeSupported))
                    Node(ocNode, "isFixedModeSupported", bool(ocCaps.isFixedModeSupported))

                    if ocCaps.isOcSupported:
                        try:
                            frq = zeCall(zesFrequencyOcGetFrequencyTarget(freq))
                            ocFreq = "%.1f" % frq
                        except:
                            ocFreq = "?"
                        Node(ocNode, "CurrentOcFrequencyTarget", ocFreq, ("Units", "MHz"))
                        try:
                            tgt, off = zeCall(zesFrequencyOcGetVoltageTarget(freq))
                            vTarget, vOffset = "%.1f" % tgt, "%.1f" % off
                        except:
                            vTarget, vOffset = "?", "?"
                        Node(ocNode, "CurrentOcVoltageTarget", vTarget, ("Units", "V"))
                        Node(ocNode, "CurrentOcVoltageOffset", vOffset, ("Units", "V"))

                    if ocCaps.isIccMaxSupported:
                        try:
                            icc = zeCall(zesFrequencyOcGetIccMax(freq))
                            iccMax = "%.1f" % icc
                        except:
                            iccMax = "?"
                        Node(ocNode, "OcCurrentLimit", iccMax, ("Units", "A"))

                    if ocCaps.isTjMaxSupported:
                        try:
                            tj = zeCall(zesFrequencyOcGetTjMax(freq))
                            tjMax = "%.1f" % tj
                        except:
                            tjMax = "?"
                        Node(ocNode, "OcTemperatureLimit", tjMax, ("Units", degC))

        engCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumEngineGroups(device, engCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            engs = zes_engine_handle_array(engCount.value())
            zeCall(zesDeviceEnumEngineGroups(device, engCount.cast(), engs.cast()))

        if args.show_util:
            engTop = Node(devNode, "EngineGroups", None)

            for i in range(engCount.value()):
                eng = engs[i]
                engProps = zes_typed_structure(ZES_STRUCTURE_TYPE_ENGINE_PROPERTIES)
                zeCall(zesEngineGetProperties(eng, engProps))
                engType = engTypeString(engProps.type)

                if engProps.onSubdevice:
                    engNode = Node(engTop, "EngineGroup", None, ("Index", i), ("Name", engType),
                                      ("SubdeviceId", engProps.subdeviceId))
                else:
                    engNode = Node(engTop, "EngineGroup", None, ("Index", i), ("Name", engType))

                if args.show_telemetry:
                    utilStats = zes_engine_stats_t()
                    try:
                        zeCall(zesEngineGetActivity(eng, utilStats))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        reportZeException()
                    else:
                        node = Node(engNode, "Activity", "?", ("Units", "%"))

                        def utilTelemetry(eng=eng, utilStats=utilStats, node=node):
                            oldActive, oldTimestamp = utilStats.activeTime, utilStats.timestamp
                            zeCall(zesEngineGetActivity(eng, utilStats))
                            deltaA = utilStats.activeTime - oldActive
                            deltaT = utilStats.timestamp - oldTimestamp
                            if deltaT > 0:
                                util = "%.0f" % (100.0 * deltaA / deltaT)
                            else:
                                util = "?"
                            node.setText(util)

                        telemetryClosures.append(utilTelemetry)
                        pollDelayRequired = True

        memCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumMemoryModules(device, memCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            mems = zes_mem_handle_array(memCount.value())
            zeCall(zesDeviceEnumMemoryModules(device, memCount.cast(), mems.cast()))

        if args.show_mem:
            memTop = Node(devNode, "MemoryModules", None)

            for i in range(memCount.value()):
                mem = mems[i]
                memProps = zes_typed_structure(ZES_STRUCTURE_TYPE_MEM_PROPERTIES)
                zeCall(zesMemoryGetProperties(mem, memProps))
                memType = memTypeString(memProps.type)

                if memProps.onSubdevice:
                    memNode = Node(memTop, "MemoryModule", None, ("Index", i), ("Name", memType),
                                      ("SubdeviceId", memProps.subdeviceId))
                else:
                    memNode = Node(memTop, "MemoryModule", None, ("Index", i), ("Name", memType))

                if args.show_inventory:
                    Node(memNode, "Location", memLocString(memProps.location))
                    Node(memNode, "PhysicalSize", memProps.physicalSize, ("Units", "Bytes"))
                    Node(memNode, "BusWidth", knownvalue(memProps.busWidth))
                    Node(memNode, "NumChannels", knownvalue(memProps.numChannels))

                if args.show_telemetry:
                    memCounter = zes_mem_bandwidth_t()
                    memState = zes_typed_structure(ZES_STRUCTURE_TYPE_MEM_STATE)
                    try:
                        zeCall(zesMemoryGetBandwidth(mem, memCounter))
                        zeCall(zesMemoryGetState(mem, memState))
                    except:
                        pass
                    nodes = []
                    nodes.append(Node(memNode, "Health", "?"))
                    nodes.append(Node(memNode, "Free", "?", ("Units", "Bytes")))
                    nodes.append(Node(memNode, "Utilized", "?", ("Units", "%")))
                    nodes.append(Node(memNode, "ReadThroughput", "?", ("Units", "Bytes/s")))
                    nodes.append(Node(memNode, "WriteThroughput", "?", ("Units", "Bytes/s")))
                    nodes.append(Node(memNode, "Bandwidth", "?", ("Units", "%")))

                    def memTelemetry(mem=mem, memState=memState, memCounter=memCounter, node=nodes):
                        oldRead, oldWrite = memCounter.readCounter, memCounter.writeCounter
                        oldTimestamp = memCounter.timestamp
                        try:
                            zeCall(zesMemoryGetState(mem, memState))
                        except:
                            pass
                        else:
                            node[0].setText(memHealthString(memState.health))
                            node[1].setText(memState.free)
                            node[2].setText("%.1f" % (100.0 * (memState.size - memState.free) / memState.size))

                        try:
                            zeCall(zesMemoryGetBandwidth(mem, memCounter))
                        except:
                            pass
                        else:
                            deltaR = memCounter.readCounter - oldRead
                            deltaW = memCounter.writeCounter - oldWrite
                            deltaT = memCounter.timestamp - oldTimestamp
                            maxBW = 1.0 * memCounter.maxBandwidth
                            if deltaT > 0:
                                readThroughput = "%.1f" % (1e6 * deltaR / deltaT)
                                writeThroughput = "%.1f" % (1e6 * deltaW / deltaT)
                                if maxBW > 0:
                                    memBandwidth = "%.1f" % (1e8 * (deltaR + deltaW) / (maxBW * deltaT))
                                else:
                                    memBandwidth = "?"
                            else:
                                readThroughput = "?"
                                writeThroughput = "?"
                                memBandwidth = "?"

                            node[3].setText(readThroughput)
                            node[4].setText(writeThroughput)
                            node[5].setText(memBandwidth)

                    telemetryClosures.append(memTelemetry)
                    pollDelayRequired = True

        showPci = False
        if args.show_pci:
            pciProps = zes_typed_structure(ZES_STRUCTURE_TYPE_PCI_PROPERTIES)
            try:
                zeCall(zesDevicePciGetProperties(device, pciProps))
            except NotImplementedError:
                pass
            except ValueError:
                reportZeException()
            else:
                showPci = True

        if showPci:
            pciTop = Node(devNode, "PCI", None)
            if args.show_inventory:
                props = zes_typed_structure(ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES)
                zeCall(zesDeviceGetProperties(device, props))
                Node(pciTop, "DeviceId", hex(props.core.deviceId))
                pciAddr = pciProps.address
                address = "%02x:%02x.%x" % (pciAddr.bus, pciAddr.device, pciAddr.function)
                if pciAddr.domain != 0:
                    address = ("%04x:" % pciAddr.domain) + address
                Node(pciTop, "Address", address)
                Node(pciTop, "MaxGen", knownvalue(pciProps.maxSpeed.gen))
                Node(pciTop, "MaxLanes", knownvalue(pciProps.maxSpeed.width))
                Node(pciTop, "MaxBandwidth", fmtknown(pciProps.maxSpeed.maxBandwidth),
                     ("Units", "Bytes/s"))
                Node(pciTop, "HaveBandwidthCounters", pciProps.haveBandwidthCounters)
                Node(pciTop, "HavePacketCounters", pciProps.havePacketCounters)
                Node(pciTop, "HaveReplayCounters", pciProps.haveReplayCounters)

                if args.verbose:
                    barTop = Node(pciTop, "Bars", None)
                    barCount = uint32_ptr()
                    zeCall(zesDevicePciGetBars(device, barCount.cast(), None))
                    bars = zes_typed_array(ZES_STRUCTURE_TYPE_PCI_BAR_PROPERTIES, barCount.value())
                    zeCall(zesDevicePciGetBars(device, barCount.cast(), bars.cast()))

                    for i in range(barCount.value()):
                        bar = bars[i]
                        barName = barTypeString(bar.type)
                        barNode = Node(barTop, "Bar", None, ("Name", barName))
                        Node(barNode, "Index", bar.index)
                        Node(barNode, "Base", "0x%016x" % bar.base)
                        Node(barNode, "Size", "0x%016x" % bar.size)

            showPciTelemetry = False
            if args.show_telemetry:
                tmp = zes_typed_structure(ZES_STRUCTURE_TYPE_PCI_STATE)
                try:
                    zeCall(zesDevicePciGetState(device, tmp))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
                else:
                    showPciTelemetry = True
                del tmp

            if showPciTelemetry:
                have = { 'bw': pciProps.haveBandwidthCounters, 'pkt' : pciProps.havePacketCounters,
                         'replay' : pciProps.haveReplayCounters }
                pciState = zes_typed_structure(ZES_STRUCTURE_TYPE_PCI_STATE)
                pciCounter = zes_pci_stats_t()
                zeCall(zesDevicePciGetStats(device, pciCounter))

                nodes = []
                nodes.append(Node(pciTop, "Status", "?"))
                nodes.append(Node(pciTop, "QualityIssues", "?"))
                nodes.append(Node(pciTop, "StabilityIssues", "?"))
                nodes.append(Node(pciTop, "CurrentGen", "?"))
                nodes.append(Node(pciTop, "CurrentLanes", "?"))
                nodes.append(Node(pciTop, "CurrentBandwidth", "?", ("Units", "Bytes/s")))
                if have['bw']:
                    nodes.append(Node(pciTop, "RxThroughput", "?", ("Units", "Bytes/s")))
                    nodes.append(Node(pciTop, "TxThroughput", "?", ("Units", "Bytes/s")))
                    nodes.append(Node(pciTop, "Utilization", "?", ("Units", "%")))
                if have['pkt']:
                    nodes.append(Node(pciTop, "PacketRate", "?"))
                    if have['replay']:
                        nodes.append(Node(pciTop, "ReplayRate", "?", ("Units", "%")))
                elif have['replay']:
                        nodes.append(Node(pciTop, "ReplayRate", "?"))

                def pciTelemetry(device=device, have=have, pciState=pciState, pciCounter=pciCounter,
                                 node=nodes):
                    oldRx, oldTx = pciCounter.rxCounter, pciCounter.txCounter
                    oldPacket = pciCounter.packetCounter
                    oldReplay = pciCounter.replayCounter
                    oldTimestamp = pciCounter.timestamp
                    zeCall(zesDevicePciGetState(device, pciState))
                    zeCall(zesDevicePciGetStats(device, pciCounter))
                    deltaRx = pciCounter.rxCounter - oldRx
                    deltaTx = pciCounter.txCounter - oldTx
                    deltaPacket = pciCounter.packetCounter - oldPacket
                    deltaReplay = pciCounter.replayCounter - oldReplay
                    deltaT = pciCounter.timestamp - oldTimestamp
                    maxBW = 1.0 * pciCounter.speed.maxBandwidth
                    if deltaT > 0:
                        rxThroughput = "%.1f" % (1e6 * deltaRx / deltaT)
                        txThroughput = "%.1f" % (1e6 * deltaTx / deltaT)
                        if maxBW > 0:
                            pciUtilization = "%.1f" % (1e8 * (deltaRx + deltaTx) / (maxBW * deltaT))
                        else:
                            pciUtilization = "?"
                    else:
                        rxThroughput = "?"
                        txThroughput = "?"
                        pciUtilization = "?"

                    if have['pkt'] and deltaPacket > 0 and deltaT > 0:
                        packetRate = "%.1f" % (deltaPacket / deltaT)
                        replayRate = "%.1f" % (100.0 * deltaReplay / deltaPacket)
                    elif have['replay'] and deltaReplay > 0 and deltaT > 0:
                        packetRate = "?"
                        replayRate = "%.1f" % (deltaReplay / deltaT)
                    else:
                        packetRate = "?"
                        replayRate = "?"

                    if (pciState.speed.gen != pciCounter.speed.gen or
                        pciState.speed.width != pciCounter.speed.width or
                        pciState.speed.maxBandwidth != pciCounter.speed.maxBandwidth):

                        pr.err("WARNING: speed mismatch between PCI state/stats")

                    node[0].setText(pciLinkStatusString(pciState.status))
                    node[1].setText(pciQualityIssuesString(pciState.qualityIssues))
                    node[2].setText(pciStabilityIssuesString(pciState.stabilityIssues))
                    node[3].setText(knownvalue(pciCounter.speed.gen))
                    node[4].setText(knownvalue(pciCounter.speed.width))
                    node[5].setText(fmtknown(pciCounter.speed.maxBandwidth))
                    i = 6
                    if have['bw']:
                        node[i].setText(rxThroughput)
                        node[i+1].setText(txThroughput)
                        node[i+2].setText(pciUtilization)
                        i += 3
                    if have['pkt']:
                        node[i].setText(packetRate)
                        i += 1
                    if have['replay']:
                        node[i].setText(replayRate)

                telemetryClosures.append(pciTelemetry)
                pollDelayRequired = True

        portCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFabricPorts(device, portCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            ports = zes_fabric_port_handle_array(portCount.value())
            zeCall(zesDeviceEnumFabricPorts(device, portCount.cast(), ports.cast()))

        if (args.enable_fabric_ports is not None or args.disable_fabric_ports is not None or
            args.enable_beaconing is not None or args.disable_beaconing is not None):

            if args.enable_fabric_ports is None:
                enable_ports = []
            elif args.enable_fabric_ports == []:
                enable_ports = list(range(portCount.value()))
            else:
                enable_ports = args.enable_fabric_ports

            if args.disable_fabric_ports is None:
                disable_ports = []
            elif args.disable_fabric_ports == []:
                disable_ports = list(range(portCount.value()))
            else:
                disable_ports = args.disable_fabric_ports

            if args.enable_beaconing is None:
                enable_beacon = []
            elif args.enable_beaconing == []:
                enable_beacon = list(range(portCount.value()))
            else:
                enable_beacon = args.enable_beaconing

            if args.disable_beaconing is None:
                disable_beacon = []
            elif args.disable_beaconing == []:
                disable_beacon = list(range(portCount.value()))
            else:
                disable_beacon = args.disable_beaconing

            affected_ports = enable_ports + disable_ports + enable_beacon + disable_beacon

            for i in range(portCount.value()):
                if i in affected_ports:
                    port = ports[i]
                    portConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_CONFIG)
                    zeCall(zesFabricPortGetConfig(port, portConfig))
                    if i in enable_ports:
                        portConfig.enabled = True
                    if i in disable_ports:
                        portConfig.enabled = False
                    if i in enable_beacon:
                        portConfig.beaconing = True
                    if i in disable_beacon:
                        portConfig.beaconing = False
                    zeCall(zesFabricPortSetConfig,port, portConfig)

        if args.show_fabric_ports:
            portTop = Node(devNode, "FabricPorts", None)

            for i in range(portCount.value()):
                port = ports[i]
                portProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES)
                zeCall(zesFabricPortGetProperties(port, portProps))

                if portProps.onSubdevice:
                    portNode = Node(portTop, "FabricPort", None, ("Index", i),
                                    ("SubdeviceId", portProps.subdeviceId))
                else:
                    portNode = Node(portTop, "FabricPort", None, ("Index", i))

                if args.show_inventory:
                    portLinkType = zes_fabric_link_type_t()
                    portConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_CONFIG)

                    zeCall(zesFabricPortGetLinkType(port, portLinkType))
                    zeCall(zesFabricPortGetConfig(port, portConfig))

                    Node(portNode, "Model", portProps.model)
                    Node(portNode, "PhysicalAttachmentType", portLinkType.desc)
                    Node(portNode, "FabricId", portProps.portId.fabricId)
                    Node(portNode, "AttachId", portProps.portId.attachId)
                    Node(portNode, "PortNumber", portProps.portId.portNumber)
                    Node(portNode, "MaxRxBitrate", portProps.maxRxSpeed.bitRate, ("Units", "Bits/sec"))
                    Node(portNode, "MaxRxWidth", portProps.maxRxSpeed.width)
                    Node(portNode, "MaxTxBitrate", portProps.maxTxSpeed.bitRate, ("Units", "Bits/sec"))
                    Node(portNode, "MaxTxWidth", portProps.maxTxSpeed.width)
                    Node(portNode, "Enabled", bool(portConfig.enabled))
                    Node(portNode, "Beaconing", bool(portConfig.beaconing))

                if args.show_telemetry:
                    portState = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_STATE)
                    portCounter = zes_fabric_port_throughput_t()
                    zeCall(zesFabricPortGetThroughput(port, portCounter))
                    nodes = []
                    nodes.append(Node(portNode, "Status", "?"))
                    nodes.append(Node(portNode, "QualityIssues", "?"))
                    nodes.append(Node(portNode, "FailureReasons", "?"))
                    nodes.append(Node(portNode, "RemoteFabricId", "?"))
                    nodes.append(Node(portNode, "RemoteAttachId", "?"))
                    nodes.append(Node(portNode, "RemotePortNumber", "?"))
                    nodes.append(Node(portNode, "CurrentRxBitrate", "?", ("Units", "Bits/sec")))
                    nodes.append(Node(portNode, "CurrentRxWidth", "?"))
                    nodes.append(Node(portNode, "CurrentTxBitrate", "?", ("Units", "Bits/sec")))
                    nodes.append(Node(portNode, "CurrentTxWidth", "?"))
                    nodes.append(Node(portNode, "RxThroughput", "?", ("Units", "Bytes/s")))
                    nodes.append(Node(portNode, "TxThroughput", "?", ("Units", "Bytes/s")))

                    def portTelemetry(port=port, portState=portState, portCounter=portCounter,
                                      node=nodes):
                        oldRx, oldTx = portCounter.rxCounter, portCounter.txCounter
                        oldTimestamp = portCounter.timestamp
                        zeCall(zesFabricPortGetState(port, portState))
                        zeCall(zesFabricPortGetThroughput(port, portCounter))

                        deltaRx = portCounter.rxCounter - oldRx
                        deltaTx = portCounter.txCounter - oldTx
                        deltaT = portCounter.timestamp - oldTimestamp
                        if deltaT > 0:
                            rxThroughput = "%.1f" % (1e6 * deltaRx / deltaT)
                            txThroughput = "%.1f" % (1e6 * deltaTx / deltaT)
                        else:
                            rxThroughput = "?"
                            txThroughput = "?"

                        node[0].setText(portStatusString(portState.status))
                        node[1].setText(portQualityIssuesString(portState.qualityIssues))
                        node[2].setText(portFailureReasonsString(portState.failureReasons))
                        node[3].setText(portState.remotePortId.fabricId)
                        node[4].setText(portState.remotePortId.attachId)
                        node[5].setText(portState.remotePortId.portNumber)
                        node[6].setText(portState.rxSpeed.bitRate)
                        node[7].setText(portState.rxSpeed.width)
                        node[8].setText(portState.txSpeed.bitRate)
                        node[9].setText(portState.txSpeed.width)
                        node[10].setText(rxThroughput)
                        node[11].setText(txThroughput)

                    telemetryClosures.append(portTelemetry)
                    pollDelayRequired = True

        edomCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumRasErrorSets(device, edomCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            edoms = zes_ras_handle_array(edomCount.value())
            zeCall(zesDeviceEnumRasErrorSets(device, edomCount.cast(), edoms.cast()))

        if args.set_error_thresholds:
            i,thresholds = args.set_error_thresholds[0], args.set_error_thresholds[1:]
            try:
                assert 0 <= i < edomCount.value()
                assert 0 < len(thresholds) <= ZES_MAX_RAS_ERROR_CATEGORY_COUNT + 1
            except:
                pr.fail("ERROR: must specify a valid error domain index and 1 to",
                        ZES_MAX_RAS_ERROR_CATEGORY_COUNT + 1,"thresholds")
            else:
                if args.dry_run:
                    pr("Would set error domain", i, "thresholds to", thresholds)
                else:
                    try:
                        ras = edoms[i]
                        rasConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_CONFIG)
                        if len(thresholds) < ZES_MAX_RAS_ERROR_CATEGORY_COUNT + 1:
                            zeCall(zesRasGetConfig(ras, rasConfig))
                        else:
                            rasConfig.totalThreshold = thresholds.pop()
                        for t in range(len(thresholds)):
                            ras_category_set(rasConfig.detailedThresholds, t, thresholds[t])
                        zeCall(zesRasSetConfig(ras, rasConfig))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        reportZeException()

        if args.show_errors:
            rasTop = Node(devNode, "ErrorDomains", None)

            for i in range(edomCount.value()):
                ras = edoms[i]
                rasProps = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_PROPERTIES)
                try:
                    zeCall(zesRasGetProperties(ras, rasProps))
                except NotImplementedError:
                    continue
                except ValueError:
                    reportZeException()
                    continue
                rasType = rasTypeString(rasProps.type)

                if rasProps.onSubdevice:
                    rasNode = Node(rasTop, "ErrorDomain", None, ("Index", i), ("Name", rasType),
                                      ("SubdeviceId", rasProps.subdeviceId))
                else:
                    rasNode = Node(rasTop, "ErrorDomain", None, ("Index", i), ("Name", rasType))

                if args.show_inventory:
                    try:
                        rasConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_CONFIG)
                        zeCall(zesRasGetConfig(ras, rasConfig))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        reportZeException()
                    else:
                        thresholdNode = Node(rasNode, "Thresholds", None)
                        thresholds = rasConfig.detailedThresholds

                        Node(thresholdNode, "Resets", ras_category(thresholds, ZES_RAS_ERROR_CAT_RESET))
                        Node(thresholdNode, "ProgrammingErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_PROGRAMMING_ERRORS))
                        Node(thresholdNode, "DriverErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_DRIVER_ERRORS))
                        Node(thresholdNode, "ComputeErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_COMPUTE_ERRORS))
                        Node(thresholdNode, "NonComputeErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_NON_COMPUTE_ERRORS))
                        Node(thresholdNode, "CacheErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_CACHE_ERRORS))
                        Node(thresholdNode, "DisplayErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_DISPLAY_ERRORS))
                        Node(thresholdNode, "TotalErrors", rasConfig.totalThreshold)

                if args.show_telemetry:
                    rasState = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_STATE)

                    nodes = []
                    nodes.append(Node(rasNode, "Resets", "?"))
                    nodes.append(Node(rasNode, "ProgrammingErrors", "?"))
                    nodes.append(Node(rasNode, "DriverErrors", "?"))
                    nodes.append(Node(rasNode, "ComputeErrors", "?"))
                    nodes.append(Node(rasNode, "NonComputeErrors", "?"))
                    nodes.append(Node(rasNode, "CacheErrors", "?"))
                    nodes.append(Node(rasNode, "DisplayErrors", "?"))

                    def rasTelemetry(ras=ras, node=nodes, rasState=rasState):
                        try:
                            zeCall(zesRasGetState(ras, args.clear_errors, rasState))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            reportZeException()
                        else:
                            node[0].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_RESET))
                            node[1].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_PROGRAMMING_ERRORS))
                            node[2].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_DRIVER_ERRORS))
                            node[3].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_COMPUTE_ERRORS))
                            node[4].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_NON_COMPUTE_ERRORS))
                            node[5].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_CACHE_ERRORS))
                            node[6].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_DISPLAY_ERRORS))

                    telemetryClosures.append(rasTelemetry)

        if args.clear_errors and not args.show_telemetry:
            for i in range(edomCount.value()):
                ras = edoms[i]
                try:
                    zeCall(zesRasGetState(ras, True, None))
                except ValueError as err:
                    pr.err("workaround... ERROR: zesRasGetState returned error, ignoring...", err)

        stbyCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumStandbyDomains(device, stbyCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            stbys = zes_standby_handle_array(stbyCount.value())
            zeCall(zesDeviceEnumStandbyDomains(device, stbyCount.cast(), stbys.cast()))

        if args.set_standby is not None:
            for i in range(stbyCount.value()):
                stby = stbys[i]
                if args.set_standby.lower() in ["enabled", "en", "1", "y", "yes", "t", "true"]:
                    if args.dry_run:
                        pr("Would enable standby promotion")
                    else:
                        zeCall(zesStandbySetMode(stby, ZES_STANDBY_PROMO_MODE_DEFAULT))
                elif args.set_standby.lower() in ["disabled", "dis", "0", "n", "no", "f", "false"]:
                    if args.dry_run:
                        pr("Would disable standby promotion")
                    else:
                        zeCall(zesStandbySetMode(stby, ZES_STANDBY_PROMO_MODE_NEVER))
                else:
                    pr.err("WARNING: ignoring unrecognized set-standby value", args.set_standby)

        if args.show_standby:
            stbyTop = Node(devNode, "StandbyDomains", None)

            for i in range(stbyCount.value()):
                stby = stbys[i]
                stbyProps = zes_typed_structure(ZES_STRUCTURE_TYPE_STANDBY_PROPERTIES)
                zeCall(zesStandbyGetProperties(stby, stbyProps))
                stbyType = stbyTypeString(stbyProps.type)

                if stbyProps.onSubdevice:
                    stbyNode = Node(stbyTop, "StandbyDomain", None, ("Index", i), ("Name", stbyType),
                                    ("SubdeviceId", stbyProps.subdeviceId))
                else:
                    stbyNode = Node(stbyTop, "StandbyDomain", None, ("Index", i), ("Name", stbyType))

                if args.show_inventory:
                    modeString = stbyPromoModeString(zeCall(zesStandbyGetMode(stby)))
                    Node(stbyNode, "SleepStateMode", modeString)

        procCount = uint32_ptr()
        try:
            zeCall(zesDeviceProcessesGetState(device, procCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            procs = zes_typed_array(ZES_STRUCTURE_TYPE_PROCESS_STATE, procCount.value())
            zeCall(zesDeviceProcessesGetState(device, procCount.cast(), procs.cast()))

        if args.show_processes:
            procTop = Node(devNode, "ProcessUsages", None)

            for i in range(procCount.value()):
                proc = procs[i]
                procNode = Node(procTop, "ProcessUsage", None, ("Id", proc.processId))

                if args.show_telemetry:
                    Node(procNode, "MemUsage", "0x%08x" % proc.memSize)
                    engineNames = enginesUsedString(proc.engines)
                    Node(procNode, "EngineUsage", engineNames)

        schedCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumSchedulers(device, schedCount.cast(), None))
        except:
            pass
        else:
            scheds = zes_sched_handle_array(schedCount.value())
            zeCall(zesDeviceEnumSchedulers(device, schedCount.cast(), scheds.cast()))

        if args.set_scheduler:
            idx, schedulerArgs = args.set_scheduler[0], args.set_scheduler[1:]
            try:
                i = int(idx)
                assert 0 <= i < schedCount.value()
                sched = scheds[i]
                mode, remainder = parseSchedulerMode(schedulerArgs)
                needsReboot = False
                if mode == ZES_SCHED_MODE_TIMEOUT:
                    schedCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES)
                    watchdogTimeout, remainder = parseMicroseconds(remainder)
                    if watchdogTimeout == 0:
                        zeCall(zesSchedulerGetTimeoutModeProperties(sched, False, schedCfg))
                    else:
                        schedCfg.watchdogTimeout = watchdogTimeout
                    if args.dry_run:
                        pr("Would set scheduling mode to timeout")
                    else:
                        needsReboot = zeCall(zesSchedulerSetTimeoutMode(sched, schedCfg))
                elif mode == ZES_SCHED_MODE_TIMESLICE:
                    schedCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES)
                    interval, remainder = parseMicroseconds(remainder)
                    yieldTimeout, remainder = parseMicroseconds(remainder)
                    if interval == 0 or yieldTimeout == 0:
                        zeCall(zesSchedulerGetTimesliceModeProperties(sched, False, schedCfg))
                    if interval != 0:
                        schedCfg.interval = interval
                    if yieldTimeout != 0:
                        schedCfg.yieldTimeout = yieldTimeout
                    if args.dry_run:
                        pr("Would set scheduling mode to timeslice")
                    else:
                        needsReboot = zeCall(zesSchedulerSetTimesliceMode(sched, schedCfg))
                elif mode == ZES_SCHED_MODE_EXCLUSIVE:
                    if args.dry_run:
                        pr("Would set scheduling mode to exclusive")
                    else:
                        needsReboot = zeCall(zesSchedulerSetExclusiveMode(sched))
                elif mode == ZES_SCHED_MODE_COMPUTE_UNIT_DEBUG:
                    if args.dry_run:
                        pr("Would set scheduling mode to compute unit debug")
                    else:
                        needsReboot = zeCall(zesSchedulerSetComputeUnitDebugMode(sched))
                if remainder:
                    pr.err("WARNING: Extra set-scheduler arguments ignored")
                    pr.err(remainder)
                if needsReboot:
                    pr.err("NOTE: reboot required")
            except:
                pr.fail("Must specify a valid scheduler index and supported mode")

        if args.show_scheduler:
            schedTop = Node(devNode, "Schedulers", None)
            for i in range(schedCount.value()):
                sched = scheds[i]
                schedProps = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_PROPERTIES)
                try:
                    zeCall(zesSchedulerGetProperties(sched, schedProps))
                except NotImplementedError:
                    continue
                except ValueError:
                    reportZeException()
                    continue

                if schedProps.onSubdevice:
                    schedNode = Node(schedTop, "Scheduler", None, ("Index", i),
                                     ("SubdeviceId", rasProps.subdeviceId))
                else:
                    schedNode = Node(schedTop, "Scheduler", None, ("Index", i))

                if args.show_inventory:
                    Node(schedNode, "CanControl", bool(schedProps.canControl))
                    Node(schedNode, "Engines", enginesUsedString(schedProps.engines))
                    Node(schedNode, "SupportedModes", schedSupportedModesString(schedProps.supportedModes))
                    if args.verbose:
                        timeoutCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES)
                        zeCall(zesSchedulerGetTimeoutModeProperties(sched, True, timeoutCfg))
                        if timeoutCfg.watchdogTimeout == ZES_SCHED_WATCHDOG_DISABLE:
                            Node(schedNode, "DefaultTimeout", "Disabled")
                        else:
                            wd = timeoutCfg.watchdogTimeout / 1000.0
                            Node(schedNode, "DefaultTimeout", "%.3f" % wd, ("Units", "msec"))
                        tsCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES)
                        zeCall(zesSchedulerGetTimesliceModeProperties(sched, True, tsCfg))
                        tsi = tsCfg.interval / 1000.0
                        tsy = tsCfg.yieldTimeout / 1000.0
                        Node(schedNode, "DefaultInterval", "%.3f" % tsi, ("Units", "msec"))
                        Node(schedNode, "DefaultYieldTimeout", "%.3f" % tsy, ("Units", "msec"))

                if args.show_telemetry:
                    cfgs = [zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES),
                            zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES)]
                    nodes = []
                    nodes.append(Node(schedNode, "Mode", "?"))
                    nodes.append(Node(schedNode, "Timeout", "?", ("Units", "msec")))
                    nodes.append(Node(schedNode, "Interval", "?", ("Units", "msec")))
                    nodes.append(Node(schedNode, "YieldTimeout", "?", ("Units", "msec")))

                    def schedTelemetry(sched=sched, node=nodes, cfg=cfgs):
                        try:
                            mode = zeCall(zesSchedulerGetCurrentMode(sched))
                            if mode == ZES_SCHED_MODE_TIMEOUT:
                                zeCall(zesSchedulerGetTimeoutModeProperties(sched, False, cfg[0]))
                            elif mode == ZES_SCHED_MODE_TIMESLICE:
                                zeCall(zesSchedulerGetTimesliceModeProperties(sched, False, cfg[1]))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            reportZeException()
                        else:
                            node[0].setText(schedModeString(mode))
                            if mode == ZES_SCHED_MODE_TIMEOUT:
                                if cfg[0].watchdogTimeout == ZES_SCHED_WATCHDOG_DISABLE:
                                    node[1].setText("Disabled")
                                else:
                                    wd = cfg[0].watchdogTimeout / 1000.0
                                    node[1].setText("%.3f" % wd)
                            else:
                                node[1].setText("?")
                            if mode == ZES_SCHED_MODE_TIMESLICE:
                                tsi = cfg[1].interval / 1000.0
                                tsy = cfg[1].yieldTimeout / 1000.0
                                node[2].setText("%.3f" % tsi)
                                node[3].setText("%.3f" % tsy)
                            else:
                                node[2].setText("?")
                                node[3].setText("?")

                    telemetryClosures.append(schedTelemetry)

        diagCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumDiagnosticTestSuites(device, diagCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            diags = zes_diag_handle_array(diagCount.value())
            zeCall(zesDeviceEnumDiagnosticTestSuites(device, diagCount.cast(), diags.cast()))

        if args.show_diag:
            diagTop = Node(devNode, "TestSuites", None)

            for i in range(diagCount.value()):
                diag = diags[i]
                diagProps = zes_typed_structure(ZES_STRUCTURE_TYPE_DIAG_PROPERTIES)
                zeCall(zesDiagnosticsGetProperties(diag, diagProps))
                if diagProps.onSubdevice:
                    diagNode = Node(diagTop, "TestSuite", None, ("Index", i), ("Name", diagProps.name),
                                    ("SubdeviceId", diagProps.subdeviceId))
                else:
                    diagNode = Node(diagTop, "TestSuite", None, ("Index", i), ("Name", diagProps.name))

                if args.show_inventory and diagProps.haveTests:
                    testCount = uint32_ptr()
                    try:
                        zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), None))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        reportZeException()
                    else:
                        tests = zes_diag_test_array(testCount.value())
                        zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), tests.cast()))

                    for t in range(testCount.value()):
                        test = tests[t]
                        Node(diagNode, "Test", test.name, ("Id", test.index))

        fanCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFans(device, fanCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            fans = zes_fan_handle_array(fanCount.value())
            zeCall(zesDeviceEnumFans(device, fanCount.cast(), fans.cast()))

        if args.set_fan_speed_default:
            i, = args.set_fan_speed_default
            if 0 <= i < fanCount.value():
                try:
                    fan = fans[i]
                    zeCall(zesFanSetDefaultMode(fan))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index")

        if args.set_fan_speed_rpm:
            try:
                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))
                maxRPM = fanProps.maxRPM
            except:
                maxRPM = 1000000
            i, rpm = args.set_fan_speed_rpm
            if 0 <= i < fanCount.value() and 0 <= rpm <= maxRPM:
                try:
                    fan = fans[i]
                    speed = zes_fan_speed_t()
                    speed.speed = rpm
                    speed.units = ZES_FAN_SPEED_UNITS_RPM
                    zeCall(zesFanSetFixedSpeedMode(fan, speed))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index")

        if args.set_fan_speed_percent:
            i, pct = args.set_fan_speed_percent
            if 0 <= i < fanCount.value() and 0 <= pct <= 100:
                try:
                    fan = fans[i]
                    speed = zes_fan_speed_t()
                    speed.speed = pct
                    speed.units = ZES_FAN_SPEED_UNITS_PERCENT
                    zeCall(zesFanSetFixedSpeedMode(fan, speed))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index and fan percent")

        if args.set_fan_speed_table_rpm:
            try:
                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))
                maxRPM = fanProps.maxRPM
                maxPoints = fanProps.maxPoints
            except:
                maxRPM = 1000000
                maxPoints = ZES_FAN_TEMP_SPEED_PAIR_COUNT
            i = args.set_fan_speed_table_rpm[0]
            table = []
            try:
                assert 0 <= i < fanCount.value()
                assert len(args.set_fan_speed_table_rpm) % 2
                temp = -274
                for s in range(1, len(args.set_fan_speed_table_rpm), 2):
                    entry = (args.set_fan_speed_table_rpm[s], args.set_fan_speed_table_rpm[s+1])
                    assert entry[0] > temp
                    temp = entry[0]
                    assert 0 <= entry[1] <= maxRPM
                    table.append(entry)
                assert len(table) <= ZES_FAN_TEMP_SPEED_PAIR_COUNT
                assert len(table) <= maxPoints
            except:
                table = []

            if table:
                try:
                    fan = fans[i]
                    fanTable = zes_fan_speed_table_t()
                    tempSpeed = zes_fan_temp_speed_array(len(table))
                    for t,entry in indexed(table):
                        item = tempSpeed[t]
                        item.temperature = entry[0]
                        item.speed.speed = entry[1]
                        item.speed.units = ZES_FAN_SPEED_UNITS_RPM
                        tempSpeed[t] = item
                    fan_speed_table_set(fanTable, len(table), tempSpeed.cast())
                    zeCall(zesFanSetSpeedTableMode(fan, fanTable))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index and rpm table")

        if args.set_fan_speed_table_percent:
            try:
                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))
                maxPoints = fanProps.maxPoints
            except:
                maxPoints = ZES_FAN_TEMP_SPEED_PAIR_COUNT
            i = args.set_fan_speed_table_percent[0]
            table = []
            try:
                assert 0 <= i < fanCount.value()
                assert len(args.set_fan_speed_table_percent) % 2
                temp = -274
                for s in range(1, len(args.set_fan_speed_table_percent), 2):
                    entry = (args.set_fan_speed_table_percent[s], args.set_fan_speed_table_percent[s+1])
                    assert entry[0] > temp
                    temp = entry[0]
                    assert 0 <= entry[1] <= 100
                    table.append(entry)
                assert len(table) <= ZES_FAN_TEMP_SPEED_PAIR_COUNT
                assert len(table) <= maxPoints
            except:
                table = []

            if table:
                try:
                    fan = fans[i]
                    fanTable = zes_fan_speed_table_t()
                    tempSpeed = zes_fan_temp_speed_array(len(table))
                    for t,entry in indexed(table):
                        item = tempSpeed[t]
                        item.temperature = entry[0]
                        item.speed.speed = entry[1]
                        item.speed.units = ZES_FAN_SPEED_UNITS_PERCENT
                        tempSpeed[t] = item
                    fan_speed_table_set(fanTable, len(table), tempSpeed.cast())
                    zeCall(zesFanSetSpeedTableMode(fan, fanTable))
                except NotImplementedError:
                    pass
                except ValueError:
                    reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index and fan percent table")

        if args.show_fans:
            fanTop = Node(devNode, "Fans", None)

            for i in range(fanCount.value()):
                fan = fans[i]

                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))

                if fanProps.onSubdevice:
                    fanNode = Node(fanTop, "Fan", None, ("Index", i),
                                   ("SubdeviceId", fanProps.subdeviceId))
                else:
                    fanNode = Node(fanTop, "Fan", None, ("Index", i))

                fanConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_CONFIG)
                zeCall(zesFanGetConfig(fan, fanConfig))

                if args.show_inventory:
                    Node(fanNode, "CanControl", bool(fanProps.canControl))
                    Node(fanNode, "SupportedModes", supportedFanModesString(fanProps.supportedModes))
                    Node(fanNode, "SupportedUnits", supportedFanUnitsString(fanProps.supportedUnits))
                    Node(fanNode, "MaxRPM", knownvalue(fanProps.maxRPM))
                    Node(fanNode, "MaxPoints", knownvalue(fanProps.maxPoints, "Unsupported"))
                    Node(fanNode, "Mode", fanModeString(fanConfig.mode))
                    if fanConfig.mode == ZES_FAN_SPEED_MODE_FIXED:
                        Node(fanNode, "FixedSpeed", fanConfig.speedFixed.speed,
                             ("Units", fanUnitString(fanConfig.speedFixed.units)))
                    # if fanConfig.mode == ZES_FAN_SPEED_MODE_TABLE:
                        # tableSize = fanConfig.speedTable.numPoints
                        # tempSpeed = zes_fan_temp_speed_array(tableSize)
                        # fan_config_speed_table_get(fanConfig, tableSize, tempSpeed.cast())
                        # numPoints = min(tableSize, ZES_FAN_TEMP_SPEED_PAIR_COUNT)
                        # for s in range(numPoints):
                        #     fanTemp = Node(fanNode, "TempSpeed", None)
                        #     item = tempSpeed[s]
                        #     Node(fanTemp, "Temp", item.temperature, ("Units", degC))
                        #     Node(fanTemp, "Speed", item.speed.speed, ("Index", s),
                        #          ("Units", fanUnitString(item.speed.units)))

                if args.show_telemetry:
                    nodes = []
                    nodes.append(Node(fanNode, "Speed", "?",
                                 ("Units", fanUnitString(ZES_FAN_SPEED_UNITS_RPM))))
                    nodes.append(Node(fanNode, "Speed", "?",
                                 ("Units", fanUnitString(ZES_FAN_SPEED_UNITS_PERCENT))))

                    def fanTelemetry(fan=fan, node=nodes):
                        try:
                            rpm = zeCall(zesFanGetState(fan, ZES_FAN_SPEED_UNITS_RPM))
                            pct = zeCall(zesFanGetState(fan, ZES_FAN_SPEED_UNITS_PERCENT))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            reportZeException()
                        else:
                            node[0].setText(rpm)
                            node[1].setText(pct)

                    telemetryClosures.append(fanTelemetry)

        fwCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFirmwares(device, fwCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            fws = zes_firmware_handle_array(fwCount.value())
            zeCall(zesDeviceEnumFirmwares(device, fwCount.cast(), fws.cast()))

        if args.flash_firmware:
            filename, = args.flash_firmware
            names = ["%s [%s]" % (d,deviceUUID(u)) for d,u in zip(deviceIDs,deviceUUIDs)]
            pr("Requesting flash of", filename, "to the following devices:")
            pr(" " + "\n ".join(names))

            if not args.yes:
                answer = input("Do you really want to flash? ")
                args.yes = answer.lower() in ("y", "yes")

            if args.yes:
                if args.dry_run:
                    pr("Would flash device(s) now")
                else:
                    pr("Preparing to flash devices")
                    zeCall(zesDeviceReset(devices[0], args.force))
                    size = uint32_ptr()
                    with open(filename, "rb") as f:
                        image = f.read()
                    for i in range(fwCount.value()):
                        fw = fws[i]
                        pr("Flashing device", names[i])
                        # zeCall(zesFirmwareFlash(fw, image, len(image)))
                        zeCall(zesFirmwareFlashData(fw, image))
            else:
                pr("NOT flashing device(s)")

            sys.exit(0)

        if args.show_firmware:
            fwTop = Node(devNode, "Firmwares", None)

            for i in range(fwCount.value()):
                fw = fws[i]

                fwProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FIRMWARE_PROPERTIES)
                zeCall(zesFirmwareGetProperties(fw, fwProps))

                if fwProps.onSubdevice:
                    fwNode = Node(fwTop, "Firmware", None, ("Index", i),
                                   ("SubdeviceId", fwProps.subdeviceId))
                else:
                    fwNode = Node(fwTop, "Firmware", None, ("Index", i))

                if args.show_inventory:
                    Node(fwNode, "CanControl", bool(fwProps.canControl))
                    Node(fwNode, "Name", fwProps.name)
                    Node(fwNode, "Version", fwProps.version)

        ledCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumLeds(device, ledCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            leds = zes_led_handle_array(ledCount.value())
            zeCall(zesDeviceEnumLeds(device, ledCount.cast(), leds.cast()))

        if args.enable_led:
            i, = args.enable_led
            if 0 <= i < ledCount.value():
                if args.dry_run:
                    pr("Would enable led", i)
                else:
                    try:
                        led = leds[i]
                        zeCall(zesLedSetState(led, True))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        reportZeException()
            else:
                pr.fail("ERROR: must specify a valid led index")

        if args.disable_led:
            i, = args.disable_led
            if 0 <= i < ledCount.value():
                if args.dry_run:
                    pr("Would disable led", i)
                else:
                    try:
                        led = leds[i]
                        zeCall(zesLedSetState(led, False))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        reportZeException()
            else:
                pr.fail("ERROR: must specify a valid led index")

        if args.set_led_color:
            idx,colors = args.set_led_color[0], args.set_led_color[1:]
            if len(colors) == 1:
                ledColors = {
                    "white" : (1.0, 1.0, 1.0),
                    "yellow" : (1.0, 1.0, 0.0),
                    "magenta" : (1.0, 0.0, 1.0),
                    "red" : (1.0, 0.0, 0.0),
                    "gray" : (0.5, 0.5, 0.5),
                    "grey" : (0.5, 0.5, 0.5),
                    "cyan" : (0.0, 1.0, 1.0),
                    "green" : (0.0, 1.0, 0.0),
                    "blue" : (0.0, 0.0, 1.0),
                    "black" : (0.0, 0.0, 0.0) }
                colorStr, = colors
                colors = ledColors.get(colorStr.lower())
            try:
                i = int(idx)
                assert 0 <= i < ledCount.value()
                redStr, greenStr, blueStr = colors
                red, green, blue = float(redStr), float(greenStr), float(blueStr)
                assert 0.0 <= red <= 1.0
                assert 0.0 <= green <= 1.0
                assert 0.0 <= blue <= 1.0
            except:
                pr.fail("ERROR: must specify a valid led index and color name or triplet 0-1 0-1 0-1")
            else:
                color = zes_led_color_t()
                color.red, color.green, color.blue = red, green, blue
                if args.dry_run:
                    pr("Would set led", i, "color to", colorString(color))
                else:
                    try:
                        led = leds[i]
                        zeCall(zesLedSetColor(led, color))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        reportZeException()

        if args.show_leds:
            ledTop = Node(devNode, "Leds", None)

            for i in range(ledCount.value()):
                led = leds[i]

                ledProps = zes_typed_structure(ZES_STRUCTURE_TYPE_LED_PROPERTIES)
                zeCall(zesLedGetProperties(led, ledProps))

                if ledProps.onSubdevice:
                    ledNode = Node(ledTop, "Led", None, ("Index", i),
                                   ("SubdeviceId", ledProps.subdeviceId))
                else:
                    ledNode = Node(ledTop, "Led", None, ("Index", i))

                if args.show_inventory:
                    Node(ledNode, "CanControl", bool(ledProps.canControl))
                    Node(ledNode, "HaveRGB", bool(ledProps.haveRGB))

                if args.show_telemetry:
                    ledState = zes_typed_structure(ZES_STRUCTURE_TYPE_LED_STATE)
                    nodes = []
                    nodes.append(Node(ledNode, "State", "?"))
                    if ledProps.haveRGB:
                        nodes.append(Node(ledNode, "Color", "?"))

                    def ledTelemetry(led=led, node=nodes, ledState=ledState):
                        try:
                            zeCall(zesLedGetState(led, ledState))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            reportZeException()
                        else:
                            node[0].setText(onOffString(ledState.isOn))
                            if len(node) > 1:
                                node[1].setText(colorString(ledState.color))

                    telemetryClosures.append(ledTelemetry)

        perfCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumPerformanceFactorDomains(device, perfCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            perfs = zes_perf_handle_array(perfCount.value())
            zeCall(zesDeviceEnumPerformanceFactorDomains(device, perfCount.cast(), perfs.cast()))

        if args.set_perf:
            idx,valStr = args.set_perf
            try:
                i = int(idx)
                assert 0 <= i < perfCount.value()
                val = float(valStr)
                assert 0.0 <= val <= 100.0
            except:
                pr.fail("ERROR: must specify a valid performance factor index and value (0 - 100)")
            else:
                if args.dry_run:
                    pr("Would set performance factor", i, "to", val)
                else:
                    try:
                        perf = perfs[i]
                        zeCall(zesPerformanceFactorSetConfig(perf, val))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        reportZeException()

        if args.show_perf:
            perfTop = Node(devNode, "PerformanceFactors", None)

            for i in range(perfCount.value()):
                perf = perfs[i]

                perfProps = zes_typed_structure(ZES_STRUCTURE_TYPE_PERF_PROPERTIES)
                zeCall(zesPerformanceFactorGetProperties(perf, perfProps))

                if perfProps.onSubdevice:
                    perfNode = Node(perfTop, "PerformanceFactor", None, ("Index", i),
                                   ("SubdeviceId", perfProps.subdeviceId))
                else:
                    perfNode = Node(perfTop, "PerformanceFactor", None, ("Index", i))

                if args.show_inventory:
                    Node(perfNode, "Engines", enginesUsedString(perfProps.engines))

                if args.show_telemetry:
                    nodes = []
                    nodes.append(Node(perfNode, "Value", "?", ("Units", "%")))

                    def perfTelemetry(perf=perf, node=nodes):
                        try:
                            val = zeCall(zesPerformanceFactorGetConfig(perf))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            reportZeException()
                        else:
                            node[0].setText(val)

                    telemetryClosures.append(perfTelemetry)

        psuCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumPsus(device, psuCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            reportZeException()
        else:
            psus = zes_psu_handle_array(psuCount.value())
            zeCall(zesDeviceEnumPsus(device, psuCount.cast(), psus.cast()))

        if args.set_perf:
            idx,valStr = args.set_perf
            try:
                i = int(idx)
                assert 0 <= i < perfCount.value()
                val = float(valStr)
                assert 0.0 <= val <= 100.0
            except:
                pr.fail("ERROR: must specify a valid performance factor index and value (0 - 100)")
            else:
                if args.dry_run:
                    pr("Would set performance factor", i, "to", val)
                else:
                    try:
                        perf = perfs[i]
                        zeCall(zesPerformanceFactorSetConfig(perf, val))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        reportZeException()

        if args.show_psu:
            psuTop = Node(devNode, "PowerSupplies", None)

            for i in range(psuCount.value()):
                psu = psus[i]

                psuProps = zes_typed_structure(ZES_STRUCTURE_TYPE_PSU_PROPERTIES)
                zeCall(zesPsuGetProperties(psu, psuProps))

                if psuProps.onSubdevice:
                    psuNode = Node(psuTop, "PowerSupply", None, ("Index", i),
                                   ("SubdeviceId", psuProps.subdeviceId))
                else:
                    psuNode = Node(psuTop, "PowerSupply", None, ("Index", i))

                if args.show_inventory:
                    Node(psuNode, "HaveFan", bool(psuProps.haveFan))
                    Node(psuNode, "CurrentLimit", fmtknown(psuProps.ampLimit / 1000, "%.3f"),
                         ('Units', 'Amps'))

                if args.show_telemetry:
                    psuState = zes_typed_structure(ZES_STRUCTURE_TYPE_PSU_STATE)
                    nodes = []
                    nodes.append(Node(psuNode, "VoltageStatus", "?"))
                    nodes.append(Node(psuNode, "FanFailed", "?"))
                    nodes.append(Node(psuNode, "Temperature", "?"))
                    nodes.append(Node(psuNode, "Current", "?", ('Units', 'Amps')))

                    def psuTelemetry(psu=psu, node=nodes, psuState=psuState):
                        try:
                            zeCall(zesPsuGetState(psu, psuState))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            reportZeException()
                        else:
                            node[0].setText(psuVoltageStatusString(psuState.voltStatus))
                            node[1].setText(bool(psuState.fanFailed))
                            node[2].setText(fmtknown(psuState.temperature))
                            node[3].setText(fmtknown(psuState.current / 1000, "%.3f"))

                    telemetryClosures.append(psuTelemetry)

    currentIteration = 0
    while currentIteration < maxIterations:
        if pollDelayRequired:
            time.sleep(pollInterval)

        for closure in telemetryClosures:
            closure()

        currentIteration += 1
        topNode.output(currentIteration)
        pollDelayRequired = True

    topNode.outputComplete()

if __name__ == "__main__":
    main()
